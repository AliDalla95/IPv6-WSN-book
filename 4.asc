== Wireless with Contiki

=== Preparing your device

==== Device addressing

To start working you must first define the Node ID of each node, this will be used to generate the mote's MAC address and the IPv6 addresses (link-local and global).

You can program and store to flash your own.

==== Addressing with the Z1 platform

Let's use the ID from the motelist:

[source]
----
Reference  Device       Description
--------------------------------------------------
Z1RC3301   /dev/ttyUSB0 Silicon Labs Zolertia Z1
----

The node ID should be 3301 (decimal) if not previously saved node ID is found in the flash memory.

Let’s see how Contiki uses this to derive a full IPv6 and MAC address.  At `platforms/z1/contiki-z1-main.c`

[source, perl]
----
#ifdef SERIALNUM
  if(!node_id) {
    PRINTF("Node id is not set, using Z1 product ID\n");
    node_id = SERIALNUM;
  }
#endif
node_mac[0] = 0xc1; /* Hardcoded for Z1 */
node_mac[1] = 0x0c; /* Hardcoded for Revision C */
node_mac[2] = 0x00; /* Hardcoded to arbitrary even number so that the 802.15.4 MAC address is compatible with an Ethernet MAC address - byte 0 (byte 2 in the DS ID) */
node_mac[3] = 0x00; /* Hardcoded */
node_mac[4] = 0x00; /* Hardcoded */
node_mac[5] = 0x00; /* Hardcoded */
node_mac[6] = node_id >> 8;
node_mac[7] = node_id & 0xff;
}
----

So the  node’s addresses the mote should have will be :

[source, perl]
----
MAC c1:0c:00:00:00:00:0c:e5
Node id is set to 3301.
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5
----
Where 0xce5 is the hex value corresponding to 3301.  The global address is only set when an IPv6 prefix is assigned (more about this later).

If you wish instead to have your own addressing scheme, you can edit the node_mac values at `Contiki-z1-main.c` file.  If you wish to assign a different node id value than the obtained from the product id, then you would need to store a new one in the flash memory, luckily there is already an application to do so:

Go to `examples/z1` location and replace the `158` for your own required value:

[source]
----
make clean && make burn-nodeid.upload nodeid=158 nodemac=158 && make z1-reset && make login
----
You should see the following:

[source, perl]
----
MAC c1:0c:00:00:00:00:0c:e5 Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 3301.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5
Starting 'Burn node id'
Burning node id 158
Restored node id 158
----

As you can see, now the node ID has been changed to 158, when you restart the mote you should now see that the changes are applied:

[source, perl]
----
MAC c1:0c:00:00:00:00:00:9e Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 158.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
----

==== Addressing with the RE-Mote platform

==== Set the bandwidth and channel

.Bandwidth and channels
****
Pending to fill
****

==== Set the transmission power

.Range
****
Pending to fill
****

==== Check the wireless link
.Link Quality Estimation
****
Link Quality Estimation is an integral part of assuring reliabilit in wireless networks. Various link estimation metrics have been proposed to effectively measure the quality of wireless links.

The ETX metric, or expected transmission count, is a measure of the quality of a path between two nodes in a wireless packet data network. ETX is the number of expected transmissions of a packet necessary for it to be received without error at its destination. This number varies from one to infinity. An ETX of one indicates a perfect transmission medium, where an ETX of infinity represents a completely non-functional link. Note that ETX is an expected transmission count for a future event, as opposed to an actual count of a past event. It is hence a real number, generally not an integer.

ETX can be used as the routing metric. Routes with a lower metric are preferred. In a route that includes multiple hops, the metric is the sum of the ETX of the individual hops.

LQI (Link Quality Indicator) is a digital value often provide by Chipset vendors as an indicator of how well a signal is demodulated, in terms of the strength and quality of the received packet, thus indicating a good or bad wireless medium.  The CC2420 radio frequency transceiver used by the Z1 mote typically ranges from 110 (indicates a maximum quality frame) to 50 (typically the lowest quality frames detectable by the transceiver).  The example below shows how the Packet Reception Rate decreases as the LQI decreases.

RSSI (Received Signal Strenght Indicator) is a generic radio receiver technology metric used internally in a wireless networking device to determine the amount of radio energy received in a given channel.  The end-user will likely observe an RSSI value when measuring the signal strength of a wireless network through the use of a wireless network monitoring tool like Wireshark, Kismet or Inssider.

There is no standardized relationship of any particular physical parameter to the RSSI reading, Vendors and chipset makers provide their own accuracy, granularity, and range for the actual power (measured as mW or dBm) and their range of RSSI values (from 0 to RSSI_Max), in the case of the CC2420 radio frequency transceiver on the Z1 mote, the RSSI can range from 0 to -100, values close to 0 are related to good links and values close to -100 are closely related to a bad link, due to multiple factors such as distance, environmental, obstacles, interferences, etc.  The image below shows how the Packet Reception Rate (PRR) dramatically decreases as the CC2420 RSSI values worsen.
****

=== MAC layer

=== Routing

.What is RPL?
****
RPL is IPv6 routing protocol for low power and lossy networks designed by the IETF Routing Over Low power and Lossy network (ROLL) group, used as the defacto routing protocol in Contiki.  RPL is a proactive distance vector protocol, it starts finding the routes as soon as the RPL network is initialized.

image::./images/3/image03.jpg[]

It supports three traffic patterns:  multipoint-to-point (MP2P), point-to-multipoint (P2MP) and point-to-point (P2P).
RPL builds a Destination Oriented DAGs (DODAGs) rooted towards one sink (DAG ROOT) identified by a unique identifier DODAGID.  The DODAGs are optimized using an Objective Function (OF) metric identified by an Objective Code Point (OCP), which indicates the dynamic constraints and the metrics such as hop count, latency, expected transmission count, parents selection, energy, etc.  A rank number is assigned to each node which can be used to determine its relative position and distance to the root in the DODAG.

Within a given network, there may be multiple, logically independent RPL instances.  An RPL node may belong to multiple RPL instances, and may act as a router in some and as a leaf in others.  A set of multiple DODAGs can be in an RPL INSTANCE and a node can be a member of multiple RPL INSTANCEs, but can belong to at most one DODAG per DAG INSTANCE.

A trickle timer mechanism regulates DODAG Information Object (DIO) message transmissions, which are used to build and maintain upwards routes of the DODAG, advertising its RPL instance, DODAG ID, RANK and DODAG version number.

A node can request DODAG information by sending DODAG Information Solicitation messages (DIS), soliciting DIO messages from its neighborhoods to update its routing information and join an instance.

Nodes have to monitor DIO messages before joining a DODAG, and then join a DODAG by selecting a parent Node from its neighbors using its advertised latency, OF and RANK.  Destination Advertisement Object (DAO) messages are used to maintain downward routes by selecting the preferred parent with lower rank and sending a packet to the DAG ROOT through each of the intermediate Nodes.

RPL has two mechanisms to repair the topology of the DODAG, one to to avoid looping and allow nodes to join/rejoin, and other called global repair. Global repair is initiated at the DODAG ROOT by incrementing the DODAG Version Number to create a new DODAG Version.
****

The receiver creates the RPL DAG and becomes the network root with the same prefix as the servers:

[source, perl]
----
static void
create_rpl_dag(uip_ipaddr_t *ipaddr)
{
  struct uip_ds6_addr *root_if;

  root_if = uip_ds6_addr_lookup(ipaddr);
  if(root_if != NULL) {
  rpl_dag_t *dag;
  uip_ipaddr_t prefix;

  rpl_set_root(RPL_DEFAULT_INSTANCE, ipaddr);
  dag = rpl_get_any_dag();
  uip_ip6addr(&prefix, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);
  rpl_set_prefix(dag, &prefix, 64);
  PRINTF("created a new RPL dag\n");
  } else {
  PRINTF("failed to create a new RPL DAG\n");
  }
}
----

==== Sniffer: a must have for wireless networking

One of the must-have tools when developing wireless applications is a sniffer, which is basically a promiscuous wireless interface able to capture data and decode into a human-readable format.

A packet sniffer is a must-have tool for any wireless network application, a sniffer allows to actually see what are you transmitting over the air, verifying both that the transmissions are taking place, the frames/packets are properly formatted, and that the communication is happening on a given channel.

There are commercial options available, such as the Texas Instruments SmartRF packet Sniffer (http://www.ti.com/tool/packet-sniffer), which can be executed using a CC2531 USB dongle (http://www.ti.com/tool/CC2531EMK) which allows capturing outgoing packets like the one below.

image::./images/2/image00.png[scaledwidth="75%"]

For the remainder of this practice we will use Wireshark as our Packet analyzer, and we will learn about Open Source sniffers available.

==== Short intro to Wireshark

image::./images/2/image08.png[]

This example uses Wireshark to capture and examine a packet trace.  More information and installation instructions are available at:

https://www.wireshark.org/

A packet trace is a record of traffic at some location on the network, as if a snapshot was taken of all the bits that passed across a particular wire.  The packet trace records a timestamp for each packet, along with the bits that make up the packet, from the low-layer headers to the higher-layer contents.

Wireshark runs on most operating systems, including Windows, Mac and Linux. It provides a graphical UI that shows the sequence of packets and the meaning of the bits when interpreted as protocol headers and data. The packets are color-coded to convey their meaning, and Wireshark includes various ways to filter and analyze them to let you investigate different aspects of behavior. It is widely used to troubleshoot networks.

A common usage scenario is when a person wants to troubleshoot network problems or look at the internal workings of a network protocol. An user could, for example, see exactly what happens when he or she opens up a website or set up a wireless sensor network.  It is also possible to filter and search on given packet attributes, which facilitates the debugging process.

When you open Wireshark, there’s a couple of toolbars at the top, an area called Filter, and a few boxes below in the main window. Online directly links you to Wiresharks site, a handy user guide, and information on the security of Wireshark. Under Files, you’ll find Open, which lets you open previously saved captures, and Sample Captures. You can download any of the sample captures through this website, and study the data. This will help you understand what kind of packets Wireshark can capture.

Lastly there is the Capture section. This will let you choose your Interface. You can see each of the interfaces that are available. It’ll also show you which ones are active. Clicking details will show you some pretty generic information about that interface.

Under Start, you can choose one or more interfaces to check out. Capture Options allows you to customize what information you see during a capture. Take a look at your Capture Options – here you can choose a filter, a capture file, and more. Under Capture Help, you can read up on how to capture, and you can check info on Network Media about which interfaces work on which platforms.

Let’s select an interface and click Start. To stop a capture, press the red square in the top toolbar. If you want to start a new capture, hit the green triangle which looks like a shark fin next to it. Now that you have got a finished capture, you can click File, and save, open, or merge the capture. You can print it, you can quit the program, and you can export your packet capture in a variety of ways.

Under edit you can find a certain packet, with the search options you can copy packets, you can mark (highlight) any specific packet or all the packets. Another interesting thing you can do under Edit, is resetting the time value. You’ll notice that the time is in seconds incrementing. You can reset it from the packet you’ve clicked on. You can add a comment to a packet, configure profiles and preferences.

A hands-on session using a Z1 mote as a sniffer will help using Wireshark.

==== SenSniff IEEE 802.15.4 wireless sniffer

We will use for this practice the *SenSniff* application, freely available at: https://github.com/g-oikonomou/sensniff

Paired with a Z1 mote and Wireshark (already installed in instant Contiki), this setup will allow us to understand how the wireless communication is done in Contiki.

To program the Z1 mote as a packet Sniffer go to the following location:

[source]
----
cd examples/z1/sniffer
----

In the `project-conf.h` select the channel to sniff, by changing the `RF_CHANNEL` and `CC2420_CONF_CHANNEL` definitions.  At the moment of writing this tutorial changing channels from the Sensniff application was not implemented but proposed as a feature, check the Sensniff’s `README.md` for changes and current status.

Compile and program:

[source]
----
make sniffer.upload
----

Do not open a login session because the sniffer application uses the serial port to send its findings to the sensniff python script.  Open a new terminal, and clone the sensniff project in your home folder:

[source, perl]
----
cd $HOME
git clone https://github.com/g-oikonomou/sensniff
cd sensniff/host
----

Then launch the sensniff application with the following command:

[source, perl]
----
python sensniff.py --non-interactive -d /dev/ttyUSB0 -b 115200
----

Sensniff will read data from the mote over the serial port, dissect the frames and pipe to `/tmp/sensniff` by default, now we need to connect the other extreme of the pipe to wireshark, else you will get the following warning:

[source]
----
 "Remote end not reading"
----

Which is not worrysome, it only means that the other pipe endpoint is not connected.  You can also save the sniffed frames to open later with wireshark, adding the following argument to the above command `-p name.pcap`, which will save the session output in a `name.pcap` file.  Change the naming and location where to store the file accordingly.

Open another terminal and launch wireshark with the following command, which will add the pipe as a capture interface:

[source]
----
sudo wireshark -i /tmp/sensniff
----

Select the `/tmp/sensniff` interface from the droplist and click `Start` just above.

image::./images/2/image06.png[]

Make sure that the pipe is configured to capture packets in promiscuous mode, if needed you can increase the buffer size, but 1MB is normally enough.

image::./images/2/image07.png[]

Now the captured frames should start to appear on screen.

image::./images/2/image03.png[scaledwidth="75%"]

You can add specific filters to limit the frames being shown on screen, for this example click at the `Expression` button and a list of available attributes per protocol are listed, scroll down until IEEE 802.15.4 and check the available filters.  You can also chain different filter arguments using the `Filter` box, in this case we only wanted to check the frames belonging to the `PAN 0xABCD` and coming from node `c1:0c::0309`, so we used the `wpan.dst_pan` and  `wpan.src64` attributes.

image::./images/2/image13.png[scaledwidth="75%"]

When closing the Sensniff python application, a session information is provided reporting the statistics:

[source, perl]
----
Frame Stats:
         Non-Frame: 6
         Not Piped: 377
    Dumped to PCAP: 8086
             Piped: 7709
          Captured: 8086
----

TIP: Excercise: sniff the traffic! try to filter outgoing and incoming data packets using your own custom rules.


=== UDP and TCP basics

.What is UDP?
****
UDP (User Datagram Protocol) is a communications protocol that offers a limited amount of service when messages are exchanged between devices in a network that uses the Internet Protocol (IP).

UDP is an alternative to the Transmission Control Protocol (TCP) and, together with IP, is sometimes referred to as UDP/IP. Like the Transmission Control Protocol, UDP uses the Internet Protocol to actually get a data unit (called a datagram) from one computer to another.

Unlike TCP, UDP does not provide message fragmentation and reassembling at the other end, this means that the application must be able to make sure that the entire message has arrived and is in the right order.

Network applications that want to save processing time because they have very small data units to exchange (and therefore very little message reassembling to do) may prefer UDP to TCP
****

===== Hands on: UDP example

Go to:

[source]
----
cd examples/ipv6/simple-udp-rpl
----

And open the `broadcast-example.c` and the `Makefile`. Let’s see the contents of the `Makefile`:

[source, perl]
----
UIP_CONF_IPV6=1
CFLAGS+= -DUIP_CONF_IPV6_RPL
----

The above adds the IPv6 stack and RPL routing protocol to our application.

The `broadcast-example.c` contains:

[source]
----
#include "net/ip/uip.h"
----

This is the main IP library.

[source, perl]
----
/* Network interface and stateless autoconfiguration */
#include "net/ipv6/uip-ds6.h"
/* Use simple-udp library, at core/net/ip/ */
/* The simple-udp module provides a significantly simpler API. */
#include "simple-udp.h"
static struct simple_udp_connection broadcast_connection;
----

This structure allows to store the UDP connection information and mapped callback in which to process any received message.  It is initialized below in the following call:

[source]
----
simple_udp_register(&broadcast_connection, UDP_PORT, NULL, UDP_PORT, receiver);
----

This passes to the simple-udp application the ports from/to handle the broadcasts, and the callback function to handle received broadcasts.  We pass the NULL parameter as the destination address to allow packets from any address.

The receiver callback function is shown below:

[source]
----
receiver(struct simple_udp_connection *c,
       const uip_ipaddr_t *sender_addr,
       uint16_t sender_port,
       const uip_ipaddr_t *receiver_addr,
       uint16_t receiver_port,
       const uint8_t *data,
       uint16_t datalen);
----

This application first sets a timer and when the timer expires it sets a randomly generated new timer interval (between 1 and the sending interval) to avoid flooding the network. Then it sets the IP address to the link local all-nodes multicast address as follows:

[source]
----
uip_create_linklocal_allnodes_mcast(&addr);
----

And then use the `broadcast_connection` structure (with the values passed at register) and send our data over UDP.

[source]
----
simple_udp_sendto(&broadcast_connection, "Test", 4, &addr);
----

To extend the available address information, theres a library which already allows to print the IPv6 addresses in a friendlier way, add this to the top of the file:

[source, perl]
----
#include "debug.h"
#define DEBUG DEBUG_PRINT
#include "net/ip/uip-debug.h"
----

So we can now print the multicast address, add this before the `simple_udp_sendto(...)` call:

[source, perl]
----
PRINT6ADDR(&addr);
printf("\n");
----

Now let’s modify our receiver callback and print more information about the incoming message, replace the existing receiver code with the following:

[source, perl]
----
static void
receiver(struct simple_udp_connection *c,
       const uip_ipaddr_t *sender_addr,
       uint16_t sender_port,
       const uip_ipaddr_t *receiver_addr,
       uint16_t receiver_port,
       const uint8_t *data,
       uint16_t datalen)
{
  /* Modified to print extended information */
  printf("\nData received from: ");
  PRINT6ADDR(sender_addr);
  printf("\nAt port %d from port %d with length %d\n",
        receiver_port, sender_port, datalen);
  printf("Data Rx: %s\n", data);
}
----

Before uploading your code, override the default target by writing in the terminal:

[source]
----
make TARGET=z1 savetarget
----

Now clean any previous compiled code, compile, upload your code and then restart the z1 mote, and print the serial output to screen (all in one command!):

[source]
----
make clean && make broadcast-example.upload && make z1-reset && make login
----

TIP: Upload this code to at least 2 motes and send/receive messages from neighbors.  If you have more than 1 Z1 Mote connected in your PC, remember to use the MOTES=/dev/ttyUSBx argument in the upload, reset and login commands!

You will see the following result:

[source, perl]
----
Rime started with address 193.12.0.0.0.0.0.158
MAC c1:0c:00:00:00:00:00:9e Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 158.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
Starting 'UDP broadcast example process'
Sending broadcast to -> ff02::1

Data received from: fe80::c30c:0:0:309
At port 1234 from port 1234 with length 4
Data Rx: Test
Sending broadcast to -> ff02::1
----

TIP: Exercise:  replace the _Test_ string with your group’s name and try to identify others. Also write down the node ID of other motes. This will be useful for later.

To change the sending interval you can also modify the values at:

[source]
----
#define SEND_INTERVAL  (20 * CLOCK_SECOND)
#define SEND_TIME      (random_rand() % (SEND_INTERVAL))
----

==== What is TCP?

===== Hands on: TCP example

=== Connecting to other networks

==== The Border Router

The border router or edge router is typically a device sitting at the edge of our network, which allow us to talk to outside networks using its built-in network interfaces, such as WiFI, Ethernet, Serial, etc.

In Contiki the current and most used border router application implements a serial-based interface called SLIP, it allows to connect a given mote to a host using scripts like `tunslip6` in `tools/tunslip6` over the serial port, creating a tunneled network interface, which can be given an IPv6 prefix to set the network global IPv6 addresses.

The border router application is located at `examples/ipv6/rpl-border-router`, the following code snippets are the most relevant:

[source, perl]
----
/* Request prefix until it has been received */
while(!prefix_set) {
   etimer_set(&et, CLOCK_SECOND);
   request_prefix();
   PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));
}

dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)dag_id);
if(dag != NULL) {
   rpl_set_prefix(dag, &prefix, 64);
   PRINTF("created a new RPL dag\n");
}
----

Normally is preferable to configure the border router as a non-sleeping device, so the radio receiver is always on.  You can configure the border router settings using the `project-conf.h` file.

[source]
----
#undef NETSTACK_CONF_RDC
#define NETSTACK_CONF_RDC       nullrdc_driver
----

By default the border-router applications includes a built-in web server, displaying information about the network, such as the immediate neighbors (1-hop located) and the known routes to nodes in its network.  To enable the web server, the `WITH_WEBSERVER` flag should be enabled, and by default it will add the `httpd-simple.c` application.

===== Hands on: installing the border router

To compile and upload the border router to the Mote just type:

[source]
----
make TARGET=z1 border-router.upload
----

And to connect the border router to your host run:

[source]
----
make TARGET=z1 connect-router
----

By default it will try to connect to a mote at port `/dev/ttyUSB0` using the following serial settings:  115200 baudrate, 8 bits, No parity and 1 bit stop.  If you do not specify an IPv6 prefix it will use the default `aaaa::1/64`, to specify a specific one run the tunslip tool instead using the following:

[source]
----
make TARGET=z1 connect-router PREFIX=2001:abcd:dead:beef::1/64
----

You can also compile and run the `tunslip6` tool directly from the tools location, to compile just type:

[source]
----
cd tools
cc tunslip6.c -o tunslip6
----

And to run with specific arguments, if you are required to use a Z1 mote connected to a specific serial port, or require to name your tunnel connection with a specific naming, or proxify to a given address and port.

Run `tunslip -H` for more information.

[source]
----
./tunslip -s /dev/ttyUSB0 -t tun0 2001:abcd:dead:beef::1/64
----

===== Hands on: connecting our UDP network

In the `udp-client.c` file at `examples/ipv6/rpl-udp`. set the server address to be `aaaa::1` (the host address), replace the options there (Mode 2 is default) and add:

[source, perl]
----
uip_ip6addr(&server_ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 1);
----

To verify that we have set the address correctly let's print the server address, in the `print_local_addresses` function add this to the end:

[source, perl]
----
PRINTF("Server address: ");
PRINT6ADDR(&server_ipaddr);
PRINTF("\n");
----

The UDP connection is created in the following block:

[source, perl]
----
/* new connection with remote host */
client_conn = udp_new(NULL, UIP_HTONS(UDP_SERVER_PORT), NULL);
if(client_conn == NULL) {
  PRINTF("No UDP connection available, exiting the process!\n");
  PROCESS_EXIT();
}
udp_bind(client_conn, UIP_HTONS(UDP_CLIENT_PORT));
----

And upon receiving a message the `tcpip_handler` is called to process the incoming data:

[source, perl]
----
static void
tcpip_handler(void)
{
  char *str;

  if(uip_newdata()) {
    str = uip_appdata;
    str[uip_datalen()] = '\0';
    printf("DATA recv '%s'\n", str);
  }
}
----

Compile and program the mote:

[source, perl]
----
cd examples/ipv6/rpl-udp
make TARGET=z1 savetarget
make udp-client.upload && make z1-reset && make login

Rime started with address 193.12.0.0.0.0.0.158
MAC c1:0c:00:00:00:00:00:9e Ref ID: 158
Contiki-2.6-2071-gc169b3e started. Node id is set to 158.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
Starting 'UDP client process'
UDP client process started
Client IPv6 addresses: aaaa::c30c:0:0:9e
fe80::c30c:0:0:9e
Server address: aaaa::1
Created a connection with the server :: local/remote port 8765/5678
DATA send to 1 'Hello 1'
DATA send to 1 'Hello 2'
DATA send to 1 'Hello 3'
DATA send to 1 'Hello 4'
----

*UDP Server*

The UDP server is a python script that echoes any incoming data back to the client, useful to test the bi-directional communication between the host and the network.

The `UDP6.py` script can be executed as a single-shot UDP client or as a UDP Server binded to a specific address and port, for this example we are to bind to address `aaaa::1` and port `5678`.

The script content is below:

[source, python]
----
#! /usr/bin/env python

import sys
from socket import *
from socket import error

PORT      = 5678
BUFSIZE   = 1024

#------------------------------------------------------------#
# Start a client or server application for testing
#------------------------------------------------------------#
def main():
        if len(sys.argv) < 2:
                usage()
        if sys.argv[1] == '-s':
                server()
        elif sys.argv[1] == '-c':
                client()
        else:
                usage()

#------------------------------------------------------------#
# Prints the instructions
#------------------------------------------------------------#
def usage():
        sys.stdout = sys.stderr
        print 'Usage: udpecho -s [port]            (server)'
        print 'or:    udpecho -c host [port] <file (client)'
        sys.exit(2)

#------------------------------------------------------------#
# Creates a server, echoes the message back to the client
#------------------------------------------------------------#
def server():
    if len(sys.argv) > 2:
        port = eval(sys.argv[2])
    else:
        port = PORT

    try:
        s = socket(AF_INET6, SOCK_DGRAM)
        s.bind(('aaaa::1', port))
    except Exception:
        print "ERROR: Server Port Binding Failed"
        return
    print 'udp echo server ready: %s' % port
    while 1:
        data, addr = s.recvfrom(BUFSIZE)
        print 'server received', `data`, 'from', `addr`
        s.sendto(data, addr)

#------------------------------------------------------------#
# Creates a client that sends an UDP message to a server
#------------------------------------------------------------#
def client():
    if len(sys.argv) < 3:
        usage()
    host = sys.argv[2]
    if len(sys.argv) > 3:
        port = eval(sys.argv[3])
    else:
        port = PORT
    addr = host, port
    s = socket(AF_INET6, SOCK_DGRAM)
    s.bind(('', 0))
        print 'udp echo client ready, reading stdin'
    try:
        s.sendto("hello", addr)
    except error as msg:
        print msg
    data, fromaddr = s.recvfrom(BUFSIZE)
    print 'client received', `data`, 'from', `fromaddr`

#------------------------------------------------------------#
# MAIN APP
#------------------------------------------------------------#
main()
----

To execute the `UDP6.py` script just run:

[source, perl]
----
python UDP6.py -s 5678
----

This is the expected output when running and receiving an UDP packet:

[source, perl]
----
udp echo server ready: 5678
server received 'Hello 198 from the client' from ('aaaa::c30c:0:0:9e', 8765, 0, 0)
----

The Server then echoes back the message to the UDP client to the given `8765` port, this is the expected output from the mote:

[source, perl]
----
DATA send to 1 'Hello 198'
DATA recv 'Hello 198 from the client'
----

image::./images/4/image01.jpg[]
