== CoAP, REST, HTTP, MQTT

Placeholder

=== Protocols for the IoT

Placeholder

==== RestFULL HTTP example

.What is REST?
****
REST stands for Representational State Transfer. (It is sometimes spelled "ReST".) It relies on a stateless, client-server, cacheable communications protocol - and in virtually all cases, the HTTP protocol is used.

REST and the Internet of Things (and Services) can be an excellent match. REST implementations are lightweight: HTTP clients and servers are now available even on the smallest, IP-enabled platforms.

The key abstraction of a RESTful web service is the resource, not a service. Sensors, actuators and control systems in general can be elegantly represented as resources and their service exposed through a RESTful web service.

RESTful applications use HTTP requests to post data (create and/or update), read data (e.g., make queries), and delete data. Thus, REST uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.

Despite being simple, REST is fully-featured; there's basically nothing you can do in Web Services that can't be done with a RESTful architecture. REST is not a standard.

http://www.restapitutorial.com/
****

===== HTTP API

Placeholder

===== Hands on: HTTP server

Install curl

[source, bash]
----
sudo apt-get install curl
----

In `/examples/rest-example/Makefile` switch to a HTTP build by disabling CoAP as follow `WITH_COAP = 0`.

Ensure that the two motes you will be using to test this (Border Router, HTTP server) have flashed a MAC/IPv6 address, be sure to write down the addresses!
If you get an error like the following, Go to `platform/z1/contiki-conf.h` and change `UIP_CONF_BUFFER_SIZE` to 240, or just add this to a `project-conf.h file`.

[source, bash]
----
#error "UIP_CONF_BUFFER_SIZE too small for REST_MAX_CHUNK_SIZE"
make: *** [obj_z1/er-coap-07-engine.o] Error 1
----

*Server:*

[source, bash]
----
cd /examples/rest-example/
make TARGET=z1 savetarget
make rest-server-example.upload && make z1-reset && make login
----
Write down the address, Press Ctrl + C to stop the serialdump script.

*Border-Router:*

[source, bash]
----
cd ../ipv6/rpl-border-router/
make TARGET=z1 savetarget
make border-router.upload && make connect-router
----

Don't close this window! leave the mote connected, now you will be seeing something like this:

[source, bash]
----
make connect-router
using saved target 'z1'
sudo ../../../tools/tunslip6 aaaa::1/64
SLIP started on ``/dev/ttyUSB0''
opened tun device ``/dev/tun0''
ifconfig tun0 inet `hostname` up
ifconfig tun0 add aaaa::1/64
ifconfig tun0 add fe80::0:0:0:1/64
ifconfig tun0

tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
     inet addr:127.0.1.1  P-t-P:127.0.1.1  Mask:255.255.255.255
     inet6 addr: fe80::1/64 Scope:Link
     inet6 addr: aaaa::1/64 Scope:Global
     UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:500
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

*** Address:aaaa::1 => aaaa:0000:0000:0000
Got configuration message of type P
Setting prefix aaaa::
Server IPv6 addresses:
aaaa::c30c:0:0:0
fe80::c30c:0:0:0
----

Ping both motes (the http-server in this example has `aaaa::c30c:0:0:97`):

[source, bash]
----
ping6 aaaa::c30c:0:0:97
PING aaaa::c30c:0:0:97(aaaa::c30c:0:0:97) 56 data bytes
64 bytes from aaaa::c30c:0:0:97: icmp_seq=1 ttl=63 time=41.6 ms
64 bytes from aaaa::c30c:0:0:97: icmp_seq=2 ttl=63 time=44.0 ms
64 bytes from aaaa::c30c:0:0:97: icmp_seq=3 ttl=63 time=42.4 ms

aaaa::c30c:0:0:97 ping statistics
3 packets transmitted, 3 received, 0% packet loss, time 2002ms
rtt min/avg/max/mdev = 41.641/42.706/44.023/1.016 ms
----

Discover the available resources:

[source, bash]
----
curl -H "User-Agent: curl" aaaa::c30c:0:0:0097:8080/.well-known/core
</helloworld>;n="HelloWorld",</led>;n="LedControl"
----

Now let's use curl (http client) to get information from the mote and send commands:

[source, bash]
----
curl -H "User-Agent: curl" aaaa::c30c:0:0:0097:8080/helloworld
Hello World!

curl -H "User-Agent: curl" aaaa::c30c:0:0:0097:8080/led?color=green -d mode=on -i -v
* About to connect() to aaaa::c30c:0:0:0097 port 8080 (#0)
*   Trying aaaa::c30c:0:0:97... connected
* Connected to aaaa::c30c:0:0:0097 (aaaa::c30c:0:0:97) port 8080 (#0)
> POST /led?color=green HTTP/1.1
> Host: aaaa::c30c:0:0:0097:8080
> Accept: */*
> User-Agent: curl
> Content-Length: 7
> Content-Type: application/x-www-form-urlencoded
>
< HTTP/1.1 200 OK
HTTP/1.1 200 OK
< Server: Contiki
Server: Contiki
< Connection: close
Connection: close

<
* Closing connection #0

$ curl -H "User-Agent: curl" aaaa::c30c:0:0:0097:8080/led?color=green -d mode=off -i
HTTP/1.1 200 OK
Server: Contiki
Connection: close
----

==== CoAP example

.What is CoAP?
****
The Constrained Application Protocol (CoAP) is a software protocol intended to be used in very simple electronics devices that allows them to communicate interactively over the Internet. It is particularly targeted for small low power sensors, switches, valves and similar components that need to be controlled or supervised remotely, through standard Internet networks. CoAP is an application layer protocol that is intended for use in resource-constrained internet devices, such as WSN nodes. CoAP is designed to easily translate to HTTP for simplified integration with the web, while also meeting specialized requirements such as multicast support, very low overhead, and simplicity.

CoAP can run on most devices that support UDP. CoAP makes use of two message types, requests and responses, using a simple binary base header format. The base header may be followed by options in an optimized Type-Length-Value format. CoAP is by default bound to UDP and optionally to DTLS, providing a high level of communications security.

Any bytes after the headers in the packet are considered the message body (if any is present). The length of the message body is implied by the datagram length. When bound to UDP the entire message MUST fit within a single datagram. When used with 6LoWPAN as defined in RFC 4944, messages should fit into a single IEEE 802.15.4 frame to minimize fragmentation.
****

===== CoAP API

The CoAP implementation in Contiki is located in `apps/er-coap`.

The coap engine (currently the CoAP-18 implementation) is implemented in `er-coap-engine.c`.  The engine interface is provided by a structure as follows:

[source, c]
----
const struct rest_implementation coap_rest_implementation = {
  coap_init_engine,
  coap_set_service_callback,
  coap_get_header_uri_path,
(...)
}
----

It is possible then to invoke the CoAP engine as follows:

[source, c]
----
REST.get_query_variable();
----

Web services are viewed as resources, and can be uniquely identified by their URLs. The basic REST design uses the HTTP or COAP protocol methods for typical `CRUD` operations (create, read, update, delete):

* POST: Create a resource
* GET: Retrieve a resource
* PUT: Update a resource
* DELETE: Delete a resource

There are various resources that are available at the server. Each resource at the server has a handler function which the REST layer calls to serve the request by the client. The REST server sends the response back to the client with the contents of the resource requested.

The following macros are available in `apps/rest-engine`, recommended when creating a new CoAP resource.

A *normal resource* is defined by a static Uri-Path that is associated with a resource handler function.  This is the basis for all other resource types.

[source, c]
----
#define RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \
  resource_t name = { NULL, NULL, NO_FLAGS, attributes, get_handler, post_handler, put_handler, delete_handler, { NULL } }
----

A *parent resource* manages several sub-resources by evaluating the Uri-Path, which may be longer than the parent resource.

[source, c]
----
#define PARENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \
  resource_t name = { NULL, NULL, HAS_SUB_RESOURCES, attributes, get_handler, post_handler, put_handler, delete_handler, { NULL } }
----

If the server is not able to respond immediately to a `CON` request , it simply responds with an Empty ACK message so that the client can stop re-transmitting the request. After a while, when the server is ready with the response, it sends the response as a `CON` message.  The following macro allows to create a CoAP resource with *separate response*:

[source, c]
----
#define SEPARATE_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, resume_handler) \
  resource_t name = { NULL, NULL, IS_SEPARATE, attributes, get_handler, post_handler, put_handler, delete_handler, { .resume = resume_handler } }
----

An *event resource* is similar to an periodic resource, only that the second handler is called by an irregular event such as a button.

[source, c]
----
#define EVENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, event_handler) \
  resource_t name = { NULL, NULL, IS_OBSERVABLE, attributes, get_handler, post_handler, put_handler, delete_handler, { .trigger = event_handler } }
----

If we need to declare a *periodic resource*, for example to poll a sensor and publish a changed value to subscribed clients, then we should use:

[source, c]
----
#define PERIODIC_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, period, periodic_handler) \
  periodic_resource_t periodic_##name; \
  resource_t name = { NULL, NULL, IS_OBSERVABLE | IS_PERIODIC, attributes, get_handler, post_handler, put_handler, delete_handler, { .periodic = &periodic_##name } }; \
  periodic_resource_t periodic_##name = { NULL, &name, period, { { 0 } }, periodic_handler };
----

Notice the `PERIODIC_RESOURCE` and `EVENT_RESOURCE` can be observable, meaning a client can be notified for any change in a given resource.

Once we declare and implement the resources (we will get to that in the Hands on section), we need to initializes REST framework and start the HTTP or CoAP process.  This is done using:

[source, c]
----
void rest_init_engine(void);
----

Then for each declared resource we need want to be accessible, we need to call:

[source, c]
----
void rest_activate_resource(resource_t *resource, char *path);
----

So assume we have created a `hello-world` resource in `res-hello.c`, and declared as follows:

[source, c]
----
RESOURCE(res_hello,
         "title=\"Hello world: ?len=0..\";rt=\"Text\"",
         res_get_handler,
         NULL,
         NULL,
         NULL);
----

To enable the resource we would do:

[source, c]
----
rest_activate_resource(&res_hello, "test/hello");
----

Which means the resource would be available at `test/hello` uri-Path.

The function above stores the resources into a list.  To list the available resources, the `rest_get_resources` function is used.  This will return a list with the resources with the following:

[source, c]
----
rest_get_resources();
----

Now let us put the above to work in the following hands on example.

===== Hands on: CoAP client and server

First get the Copper (Cu) CoAP user-agent from:

https://addons.mozilla.org/en-US/firefox/addon/copper-270430/

Copper is a generic browser for the Internet of Things based on the Constrained Application Protocol (CoAP), a user-friendly management tool for networked embedded devices. As it is integrated into web browsers, it allows an intuitive interaction and with the presentation layer making easier to debug existing CoAP devices.

More information available at:

http://people.inf.ethz.ch/mkovatsc/copper.php

For this practice we will use 2 motes: a Border Router and a CoAP server.

[WARNING]
====
If you are using the *Z1 motes*, Ensure that  the 2 motes you will be using to test this (border router, client, server) have flashed a Node ID to generate the MAC/IPv6 addresses as done in previous sessions, be sure to write down the addresses!  Another thing, if you get an error like the following, go to `platform/z1/contiki-conf.h` and change `UIP_CONF_BUFFER_SIZE` to 240:

[source, bash]
----
#error "UIP_CONF_BUFFER_SIZE too small for REST_MAX_CHUNK_SIZE"
make: *** [obj_z1/er-coap-07-engine.o] Error 1
----
====

In the `Makefile` we can notice two things: the `resources` folder is included as a project directory, and all the resources files are added in the compilation.

[source, c]
----
REST_RESOURCES_DIR = ./resources
REST_RESOURCES_FILES = $(notdir $(shell find $(REST_RESOURCES_DIR) -name '*.c' ! -name 'res-plugtest*'))
PROJECTDIRS += $(REST_RESOURCES_DIR)
PROJECT_SOURCEFILES += $(REST_RESOURCES_FILES)
----

The second thing is we are including the `er-coap` and `rest-engine` applications.

[source, c]
----
# REST Engine shall use Erbium CoAP implementation
APPS += er-coap
APPS += rest-engine
----

Next let us check the `project-conf.h` relevant configuration.  First we make sure TCP is disabled, as CoAP is based on UDP.

[source, c]
----
/* Disabling TCP on CoAP nodes. */
#undef UIP_CONF_TCP
#define UIP_CONF_TCP                   0
----

The `REST_MAX_CHUNK_SIZE` is the maximum buffer size that is provided for resource responses.  Larger data should be handled by the resource and be sent in CoAP blocks. The `COAP_MAX_OPEN_TRANSACTIONS` is the number of maximum open transactions the node is able to handle.  

[source, c]
----
/* Increase rpl-border-router IP-buffer when using more than 64. */
#undef REST_MAX_CHUNK_SIZE
#define REST_MAX_CHUNK_SIZE            48

/* Multiplies with chunk size, be aware of memory constraints. */
#undef COAP_MAX_OPEN_TRANSACTIONS
#define COAP_MAX_OPEN_TRANSACTIONS     4

/* Filtering .well-known/core per query can be disabled to save space. */
#undef COAP_LINK_FORMAT_FILTERING
#define COAP_LINK_FORMAT_FILTERING     0
#undef COAP_PROXY_OPTION_PROCESSING
#define COAP_PROXY_OPTION_PROCESSING   0

/* Enable client-side support for COAP observe */
#define COAP_OBSERVE_CLIENT 1
----

*CoAP Server:*

Let us walkthrough the `er-example-server.c` example and understand its implementation.  The first noticeable thing is that the folder example has a folder called resources, this is fairly simple: the resources are implemented in a different file, this makes easier to debug and maintain the example.

The resources to be included in the CoAP server are defined in the following declaration:

[source, c]
----
extern resource_t
  res_hello,
  res_mirror,
  res_chunks,
  res_separate,
  res_push,
  res_event,
  res_sub,
  res_b1_sep_b2;
#if PLATFORM_HAS_LEDS
extern resource_t res_leds, res_toggle;
#endif
#if PLATFORM_HAS_BATTERY
#include "dev/battery-sensor.h"
extern resource_t res_battery;
#endif
#if PLATFORM_HAS_RADIO
#include "dev/radio-sensor.h"
extern resource_t res_radio;
#endif
----

The resources wrapped inside the `PLATFORM_HAS_X` defines are dependant on the target platform, and will get pulled-in if the platform has those enabled.

Then the REST engine is initialized by calling the `rest_init_engine()`, and the enabled resources are binded:

[source, c]
----
/* Initialize the REST engine. */
rest_init_engine();

/*
 * Bind the resources to their Uri-Path.
 * WARNING: Activating twice only means alternate path, not two instances!
 * All static variables are the same for each URI path.
 */
rest_activate_resource(&res_hello, "test/hello");
rest_activate_resource(&res_push, "test/push");
rest_activate_resource(&res_event, "sensors/button"); */
#if PLATFORM_HAS_LEDS
  rest_activate_resource(&res_toggle, "actuators/toggle");
#endif
(...)
----

Now let us take a look at the `res-hello.c` resource, which implements a "hello world" resource for testing.

As shown before resources are defined using the `RESOURCE` macro, for this particular implementation we specify the resource name as `res_hello`, the link-formatted atributtes and the `GET` callback handler.  The `POST`, `PUT`, and `DELETE` methods are not supported by this resource, so a `NULL` parameter is used as argument.

[source, c]
----
RESOURCE(res_hello,
         "title=\"Hello world: ?len=0..\";rt=\"Text\"",
         res_get_handler,
         NULL,
         NULL,
         NULL);
----

The `res_get_handler` is the event callback for `GET` requests, its implementation

[source, c]
----
static void
res_get_handler(void *request, void *response, uint8_t *buffer, uint16_t preferred_size, int32_t *offset)
{
  const char *len = NULL;
  /* Some data that has the length up to REST_MAX_CHUNK_SIZE. For more, see the chunk resource. */
  char const *const message = "Hello World! ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy";
  int length = 12; /*          |<-------->| */                            <1>

  /* The query string can be retrieved by rest_get_query() or parsed for its key-value pairs. */
  if(REST.get_query_variable(request, "len", &len)) {                     <2>
    length = atoi(len);                                                   
    if(length < 0) {
      length = 0;
    }
    if(length > REST_MAX_CHUNK_SIZE) {                                    <4>
      length = REST_MAX_CHUNK_SIZE;
    }
    memcpy(buffer, message, length);
  } else {
    memcpy(buffer, message, length);                                      <5>
    
    /* text/plain is the default, hence this option could be omitted. */
  } REST.set_header_content_type(response, REST.type.TEXT_PLAIN);         <6>
  
  REST.set_header_etag(response, (uint8_t *)&length, 1);                  <7>
  REST.set_response_payload(response, buffer, length);                    <8>
}
----
<1> The lenght of the reply, in this case from the complete string, only `Hello World!` will be sent.
<2> Blah
<3> Blah
<4> Blah
<5> Blah
<6> Blah
<7> Blah
<8> Blah

[WARNING]
====
Be sure the settings are consistent, at the `examples/ipv6/rpl-border-router` in the `project-conf.h` file add the following:

[source, c]
----
#undef NETSTACK_CONF_RDC
#define NETSTACK_CONF_RDC     nullrdc_driver
----

Then compile and upload:

[source, bash]
----
cd examples/er-rest-example/
make TARGET=remote savetarget
make er-example-server.upload && make login
----

Write down the IPv6 server address, disconnect the mote and connect another one to be used as client.

Disconnect the mote, connect another one to be used as border-router:

*Border-Router:*

[source, bash]
----
cd ../ipv6/rpl-border-router/
make TARGET=z1 savetarget
make border-router.upload && make connect-router
----

Don't close this window! leave the mote connected, now you will be watching something like this:

[source, bash]
----
SLIP started on ``/dev/ttyUSB0''
opened tun device ``/dev/tun0''
ifconfig tun0 inet `hostname` up
ifconfig tun0 add aaaa::1/64
ifconfig tun0 add fe80::0:0:0:1/64
ifconfig tun0

tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
     inet addr:127.0.1.1  P-t-P:127.0.1.1  Mask:255.255.255.255
     inet6 addr: fe80::1/64 Scope:Link
     inet6 addr: aaaa::1/64 Scope:Global
     UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:500
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Rime started with address 193.12.0.0.0.0.3.229
MAC c1:0c:00:00:00:00:03:e5 Contiki-2.5-release-681-gc5e9d68 started. Node id is set to 997.
CSMA nullrdc, channel check rate 128 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:03e5
Starting 'Border router process' 'Web server'
Address:aaaa::1 => aaaa:0000:0000:0000
Got configuration message of type P
Setting prefix aaaa::
Server IPv6 addresses:
aaaa::c30c:0:0:3e5
fe80::c30c:0:0:3e5
----

Let's ping the border-router:

[source, c]
----
ping6 aaaa:0000:0000:0000:c30c:0000:0000:03e5
PING aaaa:0000:0000:0000:c30c:0000:0000:03e5(aaaa::c30c:0:0:3e5) 56 data bytes
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=1 ttl=64 time=21.0 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=2 ttl=64 time=19.8 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=3 ttl=64 time=22.2 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=4 ttl=64 time=20.7 ms
----

Now connect the server mote, ping it too:

[source, c]
----
ping6 aaaa:0000:0000:0000:c30c:0000:0000:0001
PING aaaa:0000:0000:0000:c30c:0000:0000:0001(aaaa::c30c:0:0:1) 56 data bytes
64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=63 time=40.3 ms
64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=63 time=34.2 ms
64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=63 time=35.7 ms
----

And connect the client mote, assuming it is connected in `/dev/ttyUSB2` port:

[source, c]
----
make login MOTES=/dev/ttyUSB2
../../tools/sky/serialdump-linux -b115200 /dev/ttyUSB2
connecting to /dev/ttyUSB2 (115200) [OK]
Rime started with address 193.12.0.0.0.0.0.158
MAC c1:0c:00:00:00:00:00:9e Contiki-2.5-release-681-gc5e9d68 started. Node id is set to 158.
CSMA nullrdc, channel check rate 128 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
Starting 'COAP Client Example'
Press a button to request .well-known/core
--Requesting .well-known/core--
|</.well-known/core>;ct=40,</hello>;title="Hello world: ?len=0.."|;rt="Text",</tes|t/push>;title="P| demo";obs,</tes|itle="Sub-resour||g|b, POST/PUT m|le="Red LED";rt=|BlockOutOfScope
--Done--
----

Now we can start discovering the Server resources, Open Firefox and type the server address:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/
----

And began by discovering the available resources, Press `DISCOVER` and the page will be populated in the left side:

If you select the `toggle` resource and use `POST` you can see how the RED led of the server mote will toggle:

If you do the same with the `Hello` resource, the server will answer you back with a neighbourly well-known message:

And finally if you observe the `Sensors`-> `Button` events by selecting it and clicking `OBSERVE`, each time you press the user button an event will be triggered and reported back:

Finally if you go to the `er-example-server.c` file and enable the following defines, you should have more resources available:

[source, c]
----
#define REST_RES_HELLO    1
#define REST_RES_SEPARATE 1
#define REST_RES_PUSHING  1
#define REST_RES_EVENT    1
#define REST_RES_SUB      1
#define REST_RES_LEDS     1
#define REST_RES_TOGGLE   1
#define REST_RES_BATTERY  1
#define REST_RES_RADIO    1
----

And now to get the current RSSI level on the transceiver:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/sensor/radio?p=rssi
----

Do the same to get the battery level readings:
[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/sensors/battery
----

This last case returns the ADC units when the mote is connected to the USB, the actual value in millivolts would be:
[source, c]
----
V [mV] = (units * 5000)/4096
----

Let's say you want to turn the green LED ON, in the URL type:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/actuators/leds?color=g
----

And then in the payload (the ongoing tab) write:

[source, c]
----
mode="on"
----

And press `POST` or `PUT` (hover with the mouse over the actuators/leds to see the description and allowed methods).

image::./images/5/image001.png[scaledwidth="75%"]


==== MQTT example

.What is MQTT?
****
Insert text
****

Pending to add

