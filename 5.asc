
== CoAP, MQTT and HTTP

In the previous section we covered some of the wireless basic, we should now have a good idea about working with Contiki.  This section introduces two widely used protocols for the IoT: CoAP and MQTT.  We will explain the basics and wrap up with ready to use examples.

=== CoAP example

The CoAP implementation in Contiki is based in Erbium (Er), a low-power REST Engine for Contiki.  The REST Engine includes a comprehensive embedded CoAP implementation, which became the official one in Contiki.

More information about its implementation and author is available in the http://people.inf.ethz.ch/mkovatsc/erbium.php[Erbium site].

.What are REST and CoAP?
****
The *Representational State Transfer (REST)* relies on a stateless, client-server, cacheable communications protocol - and in virtually all cases, the HTTP protocol can be used.

The key abstraction of a RESTful web service is the resource, not a service. Sensors, actuators and control systems in general can be elegantly represented as resources and their service exposed through a RESTful web service.

RESTful applications use HTTP-like requests to post data (create and/or update), read data (e.g., make queries), and delete data. Thus, REST uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.

Despite being simple, REST is fully-featured; there's basically nothing you can do in Web Services that can't be done with a RESTful architecture. REST is not a standard.

The *Constrained Application Protocol (CoAP)* is a software protocol intended to be used in very simple electronics devices that allows them to communicate interactively over the Internet. It is particularly targeted for small low power sensors, switches, valves and similar components that need to be controlled or supervised remotely, through standard Internet networks. CoAP is an application layer protocol that is intended for use in resource-constrained internet devices, such as WSN nodes. CoAP is designed to easily translate to HTTP for simplified integration with the web, while also meeting specialized requirements such as multicast support, very low overhead, and simplicity.

CoAP can run on most devices that support UDP. CoAP makes use of two message types, requests and responses, using a simple binary base header format. The base header may be followed by options in an optimized Type-Length-Value format. CoAP is by default bound to UDP and optionally to DTLS, providing a high level of communications security.

Any bytes after the headers in the packet are considered the message body (if any is present). The length of the message body is implied by the datagram length. When bound to UDP the entire message MUST fit within a single datagram. When used with 6LoWPAN as defined in RFC 4944, messages should fit into a single IEEE 802.15.4 frame to minimize fragmentation.
****

==== CoAP API

The CoAP implementation in Contiki is located in `apps/er-coap`.  The Erbium REST engine is implemented in `apps/rest-engine`.

The coap engine (currently the CoAP-18 implementation) is implemented in `er-coap-engine.c`.  The engine interface is provided by a structure as follows:

[source, c]
----
const struct rest_implementation coap_rest_implementation = {
  coap_init_engine,
  coap_set_service_callback,
  coap_get_header_uri_path,
(...)
}
----

It is possible then to invoke the CoAP engine as follows:

[source, c]
----
REST.get_query_variable();
----

Web services are viewed as resources, and can be uniquely identified by their URLs. The basic REST design uses the HTTP or COAP protocol methods for typical `CRUD` operations (create, read, update, delete):

* POST: Create a resource
* GET: Retrieve a resource
* PUT: Update a resource
* DELETE: Delete a resource

There are various resources that are available at the server. Each resource at the server has a handler function which the REST layer calls to serve the request by the client. The REST server sends the response back to the client with the contents of the resource requested.

The following macros are available in `apps/rest-engine`, recommended when creating a new CoAP resource.

A *normal resource* is defined by a static Uri-Path that is associated with a resource handler function.  This is the basis for all other resource types.

[source, c]
----
#define RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \
  resource_t name = { NULL, NULL, NO_FLAGS, attributes, get_handler, post_handler, put_handler, delete_handler, { NULL } }
----

A *parent resource* manages several sub-resources by evaluating the Uri-Path, which may be longer than the parent resource.

[source, c]
----
#define PARENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler) \
  resource_t name = { NULL, NULL, HAS_SUB_RESOURCES, attributes, get_handler, post_handler, put_handler, delete_handler, { NULL } }
----

If the server is not able to respond immediately to a `CON` request , it simply responds with an Empty ACK message so that the client can stop re-transmitting the request. After a while, when the server is ready with the response, it sends the response as a `CON` message.  The following macro allows to create a CoAP resource with *separate response*:

[source, c]
----
#define SEPARATE_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, resume_handler) \
  resource_t name = { NULL, NULL, IS_SEPARATE, attributes, get_handler, post_handler, put_handler, delete_handler, { .resume = resume_handler } }
----

An *event resource* is similar to an periodic resource, only that the second handler is called by an irregular event such as a button.

[source, c]
----
#define EVENT_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, event_handler) \
  resource_t name = { NULL, NULL, IS_OBSERVABLE, attributes, get_handler, post_handler, put_handler, delete_handler, { .trigger = event_handler } }
----

If we need to declare a *periodic resource*, for example to poll a sensor and publish a changed value to subscribed clients, then we should use:

[source, c]
----
#define PERIODIC_RESOURCE(name, attributes, get_handler, post_handler, put_handler, delete_handler, period, periodic_handler) \
  periodic_resource_t periodic_##name; \
  resource_t name = { NULL, NULL, IS_OBSERVABLE | IS_PERIODIC, attributes, get_handler, post_handler, put_handler, delete_handler, { .periodic = &periodic_##name } }; \
  periodic_resource_t periodic_##name = { NULL, &name, period, { { 0 } }, periodic_handler };
----

Notice the `PERIODIC_RESOURCE` and `EVENT_RESOURCE` can be observable, meaning a client can be notified for any change in a given resource.

Once we declare and implement the resources (we will get to that in the Hands on section), we need to initializes REST framework and start the HTTP or CoAP process.  This is done using:

[source, c]
----
void rest_init_engine(void);
----

Then for each declared resource we need want to be accessible, we need to call:

[source, c]
----
void rest_activate_resource(resource_t *resource, char *path);
----

So assume we have created a `hello-world` resource in `res-hello.c`, and declared as follows:

[source, c]
----
RESOURCE(res_hello,
         "title=\"Hello world: ?len=0..\";rt=\"Text\"",
         res_get_handler,
         NULL,
         NULL,
         NULL);
----

To enable the resource we would do:

[source, c]
----
rest_activate_resource(&res_hello, "test/hello");
----

Which means the resource would be available at `test/hello` uri-Path.

The function above stores the resources into a list.  To list the available resources, the `rest_get_resources` function is used.  This will return a list with the resources with the following:

[source, c]
----
rest_get_resources();
----

Remember the mandatory CoAP port is `5683`.

Now let us put the above to work in the following hands on example.

==== Hands on: CoAP server and Copper

First get the Copper (Cu) CoAP user-agent from:

https://addons.mozilla.org/en-US/firefox/addon/copper-270430/

Copper is a generic browser for the Internet of Things based on the Constrained Application Protocol (CoAP), a user-friendly management tool for networked embedded devices. As it is integrated into web browsers, it allows an intuitive interaction and with the presentation layer making easier to debug existing CoAP devices.

More information available at:

http://people.inf.ethz.ch/mkovatsc/copper.php

For this practice we will use 2 motes: a Border Router and a CoAP server.

[WARNING]
====
If you are using the *Z1 motes*, Ensure that  the 2 motes you will be using to test this (border router, client, server) have flashed a Node ID to generate the MAC/IPv6 addresses as done in previous sessions, be sure to write down the addresses!  Another thing, if you get an error like the following, go to `platform/z1/contiki-conf.h` and change `UIP_CONF_BUFFER_SIZE` to 240:

[source, bash]
----
#error "UIP_CONF_BUFFER_SIZE too small for REST_MAX_CHUNK_SIZE"
make: *** [obj_z1/er-coap-07-engine.o] Error 1
----
====

In the `Makefile` we can notice two things: the `resources` folder is included as a project directory, and all the resources files are added in the compilation.

[source, c]
----
REST_RESOURCES_DIR = ./resources
REST_RESOURCES_FILES = $(notdir $(shell find $(REST_RESOURCES_DIR) -name '*.c' ! -name 'res-plugtest*'))
PROJECTDIRS += $(REST_RESOURCES_DIR)
PROJECT_SOURCEFILES += $(REST_RESOURCES_FILES)
----

The second thing is we are including the `er-coap` and `rest-engine` applications.

[source, c]
----
# REST Engine shall use Erbium CoAP implementation
APPS += er-coap
APPS += rest-engine
----

Remove the following as we want to avoid collisions as much as possible:

[source,]
----
#undef NETSTACK_CONF_MAC
#define NETSTACK_CONF_MAC     nullmac_driver
----

Next let us check the `project-conf.h` relevant configuration.  First we make sure TCP is disabled, as CoAP is based on UDP.

[source, c]
----
/* Disabling TCP on CoAP nodes. */
#undef UIP_CONF_TCP
#define UIP_CONF_TCP                   0
----

The `REST_MAX_CHUNK_SIZE` is the maximum buffer size that is provided for resource responses.  Larger data should be handled by the resource and be sent in CoAP blocks. The `COAP_MAX_OPEN_TRANSACTIONS` is the number of maximum open transactions the node is able to handle.  

[source, c]
----
/* Increase rpl-border-router IP-buffer when using more than 64. */
#undef REST_MAX_CHUNK_SIZE
#define REST_MAX_CHUNK_SIZE            48

/* Multiplies with chunk size, be aware of memory constraints. */
#undef COAP_MAX_OPEN_TRANSACTIONS
#define COAP_MAX_OPEN_TRANSACTIONS     4

/* Filtering .well-known/core per query can be disabled to save space. */
#undef COAP_LINK_FORMAT_FILTERING
#define COAP_LINK_FORMAT_FILTERING     0
#undef COAP_PROXY_OPTION_PROCESSING
#define COAP_PROXY_OPTION_PROCESSING   0

/* Enable client-side support for COAP observe */
#define COAP_OBSERVE_CLIENT 1
----

*CoAP Server:*

Let us walkthrough the `er-example-server.c` example and understand its implementation.  The first noticeable thing is that the folder example has a folder called resources, this is fairly simple: the resources are implemented in a different file, this makes easier to debug and maintain the example.

The resources to be included in the CoAP server are defined in the following declaration:

[source, c]
----
extern resource_t
  res_hello,
  res_mirror,
  res_chunks,
  res_separate,
  res_push,
  res_event,
  res_sub,
  res_b1_sep_b2;
#if PLATFORM_HAS_LEDS
extern resource_t res_leds, res_toggle;
#endif
#if PLATFORM_HAS_BATTERY
#include "dev/battery-sensor.h"
extern resource_t res_battery;
#endif
#if PLATFORM_HAS_RADIO
#include "dev/radio-sensor.h"
extern resource_t res_radio;
#endif
----

The resources wrapped inside the `PLATFORM_HAS_X` defines are dependant on the target platform, and will get pulled-in if the platform has those enabled.

Then the REST engine is initialized by calling the `rest_init_engine()`, and the enabled resources are binded:

[source, c]
----
/* Initialize the REST engine. */
rest_init_engine();

/*
 * Bind the resources to their Uri-Path.
 * WARNING: Activating twice only means alternate path, not two instances!
 * All static variables are the same for each URI path.
 */
rest_activate_resource(&res_hello, "test/hello");
rest_activate_resource(&res_push, "test/push");
rest_activate_resource(&res_event, "sensors/button"); */
#if PLATFORM_HAS_LEDS
  rest_activate_resource(&res_toggle, "actuators/toggle");
#endif
(...)
----

Now let us take a look at the `res-hello.c` resource, which implements a "hello world" resource for testing.

As shown before resources are defined using the `RESOURCE` macro, for this particular implementation we specify the resource name as `res_hello`, the link-formatted atributtes and the `GET` callback handler.  The `POST`, `PUT`, and `DELETE` methods are not supported by this resource, so a `NULL` parameter is used as argument.

[source, c]
----
RESOURCE(res_hello,
         "title=\"Hello world: ?len=0..\";rt=\"Text\"",
         res_get_handler,
         NULL,
         NULL,
         NULL);
----

The `res_get_handler` is the event callback for `GET` requests, its implementation

[source, c]
----
static void
res_get_handler(void *request, void *response, uint8_t *buffer, uint16_t preferred_size, int32_t *offset)
{
  const char *len = NULL;
  /* Some data that has the length up to REST_MAX_CHUNK_SIZE. For more, see the chunk resource. */
  char const *const message = "Hello World! ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy";
  int length = 12;                                                        <1>

  /* The query string can be retrieved by rest_get_query() or parsed for its key-value pairs. */
  if(REST.get_query_variable(request, "len", &len)) {                     <2>
    length = atoi(len);                                                   
    if(length < 0) {                                                      <3>
      length = 0;
    }
    if(length > REST_MAX_CHUNK_SIZE) {                                    <4>
      length = REST_MAX_CHUNK_SIZE;
    }
    memcpy(buffer, message, length);
  } else {
    memcpy(buffer, message, length);                                      <5>
    
    /* text/plain is the default, hence this option could be omitted. */
  } REST.set_header_content_type(response, REST.type.TEXT_PLAIN);         <6>
  
  REST.set_header_etag(response, (uint8_t *)&length, 1);                  <7>
  REST.set_response_payload(response, buffer, length);                    <8>
}
----
<1> The default lenght of the reply, in this case from the complete string, only `Hello World!` will be sent
<2> If the `len` option is specified, then a number of `len` bytes of the `message` string will be sent
<3> If the value is a negative one, send end an empty string
<4> If `len` is higher than the maximum allowed, then we only send the maximum lenght value
<5> Copy the default
<6> Set the response content type as `Content-Type:text/plain`
<7> Attach the header to the response, set the payload lenght field
<8> Attach the payload to the response

[WARNING]
====
Be sure the settings are consistent with the ones of the border router, 
====

In the `project-conf.h` file add the following for this test purpose:

[source, c]
----
#undef NETSTACK_CONF_RDC
#define NETSTACK_CONF_RDC     nullrdc_driver
----

Then compile and upload:

[source, bash]
----
cd examples/er-rest-example/
make TARGET=zoul savetarget
make er-example-server.upload && make login
----

Write down the IPv6 server address, disconnect the mote and connect another one to be used as client.

Disconnect the mote, connect another one to be used as border-router:

*Border-Router:*

[source, bash]
----
cd ../ipv6/rpl-border-router/
make TARGET=z1 savetarget
make border-router.upload && make connect-router
----

Or use also:

[source, bash]
----
make TARGET=zoul savetarget && make border-router.upload && make connect-router
----

Don't close this window! leave the mote connected, now you will be watching something like this:

[source, bash]
----
SLIP started on ``/dev/ttyUSB0''
opened tun device ``/dev/tun0''
ifconfig tun0 inet `hostname` up
ifconfig tun0 add aaaa::1/64
ifconfig tun0 add fe80::0:0:0:1/64
ifconfig tun0

tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
     inet addr:127.0.1.1  P-t-P:127.0.1.1  Mask:255.255.255.255
     inet6 addr: fe80::1/64 Scope:Link
     inet6 addr: aaaa::1/64 Scope:Global
     UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
     RX packets:0 errors:0 dropped:0 overruns:0 frame:0
     TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
     collisions:0 txqueuelen:500
     RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Rime started with address 193.12.0.0.0.0.3.229
MAC c1:0c:00:00:00:00:03:e5 Contiki-2.5-release-681-gc5e9d68 started. Node id is set to 997.
CSMA nullrdc, channel check rate 128 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:03e5
Starting 'Border router process' 'Web server'
Address:aaaa::1 => aaaa:0000:0000:0000
Got configuration message of type P
Setting prefix aaaa::
Server IPv6 addresses:
aaaa::c30c:0:0:3e5
fe80::c30c:0:0:3e5
----

Let's ping the border-router:

[source, c]
----
ping6 aaaa:0000:0000:0000:c30c:0000:0000:03e5
PING aaaa:0000:0000:0000:c30c:0000:0000:03e5(aaaa::c30c:0:0:3e5) 56 data bytes
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=1 ttl=64 time=21.0 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=2 ttl=64 time=19.8 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=3 ttl=64 time=22.2 ms
64 bytes from aaaa::c30c:0:0:3e5: icmp_seq=4 ttl=64 time=20.7 ms
----

Now connect the server mote, ping it too:

[source, c]
----
ping6 aaaa:0000:0000:0000:c30c:0000:0000:0001
PING aaaa:0000:0000:0000:c30c:0000:0000:0001(aaaa::c30c:0:0:1) 56 data bytes
64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=63 time=40.3 ms
64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=63 time=34.2 ms
64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=63 time=35.7 ms
----

Now we can start discovering the Server resources, Open Firefox and type the server address:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/
----

And began by discovering the available resources, Press `DISCOVER` and the page will be populated in the left side:

If you select the `toggle` resource and use `POST` you can see how the RED led of the server mote will toggle:

If you do the same with the `Hello` resource, the server will answer you back with a neighbourly well-known message:

And finally if you observe the `Sensors`-> `Button` events by selecting it and clicking `OBSERVE`, each time you press the user button an event will be triggered and reported back:

Finally if you go to the `er-example-server.c` file and enable the following defines, you should have more resources available:

[source, c]
----
#define REST_RES_HELLO    1
#define REST_RES_SEPARATE 1
#define REST_RES_PUSHING  1
#define REST_RES_EVENT    1
#define REST_RES_SUB      1
#define REST_RES_LEDS     1
#define REST_RES_TOGGLE   1
#define REST_RES_BATTERY  1
#define REST_RES_RADIO    1
----

And now to get the current RSSI level on the transceiver:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/sensor/radio?p=rssi
----

Do the same to get the battery level readings:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/sensors/battery
----

This last case returns the ADC units when the mote is connected to the USB, the actual value in millivolts would be:

[source, c]
----
V [mV] = (units * 5000)/4096
----

Let's say you want to turn the green LED ON, in the URL type:

[source, c]
----
coap://[aaaa::c30c:0000:0000:0001]:5683/actuators/leds?color=g
----

And then in the payload (the ongoing tab) write:

[source, c]
----
mode="on"
----

And press `POST` or `PUT` (hover with the mouse over the actuators/leds to see the description and allowed methods).

.Copper CoAP plugin Screenshot
image::./images/5/image001.png[]

=== MQTT example

.What is MQTT?
****
MQTT (formerly MQ Telemetry Transport) is a publish-subscribe based messaging protocol on top of the TCP/IP protocol. It is designed for connections with remote locations where a "small code footprint" is required or the network bandwidth is limited. 

The publish-subscribe messaging pattern requires a message broker. The broker is responsible for distributing messages to interested clients based on the topic of a message.

.MQTT publish/suscribe
image::./images/5/image002.png[]

MQTT has defined three levels of Quality of Service (QoS):

* QoS 0: The broker/client will deliver the message once, with no confirmation (fire and forget)
* QoS 1: The broker/client will deliver the message at least once, with confirmation required.
* QoS 3: The broker/client will deliver the message exactly once by using a four-step handshake.

Other features of MQTT are:

* Keep-Alive message (PINGREQ, PINGRESP).
* A broker can detect client disconnection, even without an explicit `DISCONNECT` message.
* “Last Will and Testament” message: specified in `CONNECT` message with topic, QoS and retain. On unexpected client disconnection, it the “Last Will and Testament” message is sent to to subscribed clients.
* “Retain” message: a `PUBLISH` message on a topic is kept on the broker which allows a new connected subscriber on the same topic to receive this message (last known good message).
* “Durable” subscription: on client disconnection, all subscriptions are kept on the broker and recovered on client reconnection.

MQTT reserves TCP/IP port 1883 and 8883, the later for using MQTT over SSL.

For more complete information on MQTT, see http://mqtt.org/[http://mqtt.org/].
****

==== MQTT API

MQTT is implemented in Contiki in `apps/mqtt`.  It makes use of the `tcp-socket` library discussed in an early section.

The current MQTT version implemented in Contiki supports QoS levels 0 and 1.

The MQTT available functions are described next.  A hands on example in the next section will help to clarify its use and suggest a tate-machine approach to maintain the connection state and device operation.

This function initializes the MQTT engine and shall be called before any other MQTT function.

[source, c]
----
/**
 * \brief Initializes the MQTT engine.
 * \param conn A pointer to the MQTT connection.
 * \param app_process A pointer to the application process handling the MQTT
 *        connection.
 * \param client_id A pointer to the MQTT client ID.
 * \param event_callback Callback function responsible for handling the
 *        callback from MQTT engine.
 * \param max_segment_size The TCP segment size to use for this MQTT/TCP
 *        connection.
 * \return MQTT_STATUS_OK or MQTT_STATUS_INVALID_ARGS_ERROR
 */
mqtt_status_t mqtt_register(struct mqtt_connection *conn,
                            struct process *app_process,
                            char *client_id,
                            mqtt_event_callback_t event_callback,
                            uint16_t max_segment_size);
----

This function connects to a MQTT broker.

[source, c]
----
/**
 * \brief Connects to a MQTT broker.
 * \param conn A pointer to the MQTT connection.
 * \param host IP address of the broker to connect to.
 * \param port Port of the broker to connect to, default is MQTT port is 1883.
 * \param keep_alive Keep alive timer in seconds. Used by broker to handle
 *        client disc. Defines the maximum time interval between two messages
 *        from the client. Shall be min 1.5 x report interval.
 * \return MQTT_STATUS_OK or an error status
 */
mqtt_status_t mqtt_connect(struct mqtt_connection *conn,
                           char *host,
                           uint16_t port,
                           uint16_t keep_alive);
----

This function disconnects from a MQTT broker.

[source, c]
----
/**
 * \brief Disconnects from a MQTT broker.
 * \param conn A pointer to the MQTT connection.
 */
void mqtt_disconnect(struct mqtt_connection *conn);
----

This function subscribes to a topic on a MQTT broker.

[source, c]
----
/**
 * \brief Subscribes to a MQTT topic.
 * \param conn A pointer to the MQTT connection.
 * \param mid A pointer to message ID.
 * \param topic A pointer to the topic to subscribe to.
 * \param qos_level Quality Of Service level to use. Currently supports 0, 1.
 * \return MQTT_STATUS_OK or some error status
 */
mqtt_status_t mqtt_subscribe(struct mqtt_connection *conn,
                             uint16_t *mid,
                             char *topic,
                             mqtt_qos_level_t qos_level);
----

This function unsubscribes from a topic on a MQTT broker.

[source, c]
----
/**
 * \brief Unsubscribes from a MQTT topic.
 * \param conn A pointer to the MQTT connection.
 * \param mid A pointer to message ID.
 * \param topic A pointer to the topic to unsubscribe from.
 * \return MQTT_STATUS_OK or some error status
 */
mqtt_status_t mqtt_unsubscribe(struct mqtt_connection *conn,
                               uint16_t *mid,
                               char *topic);
----

This function publishes to a topic on a MQTT broker.

[source, c]
----
/**
 * \brief Publish to a MQTT topic.
 * \param conn A pointer to the MQTT connection.
 * \param mid A pointer to message ID.
 * \param topic A pointer to the topic to subscribe to.
 * \param payload A pointer to the topic payload.
 * \param payload_size Payload size.
 * \param qos_level Quality Of Service level to use. Currently supports 0, 1.
 * \param retain If the RETAIN flag is set to 1, in a PUBLISH Packet sent by a
 *        Client to a Server, the Server MUST store the Application Message
 *        and its QoS, so that it can be delivered to future subscribers whose
 *        subscriptions match its topic name
 * \return MQTT_STATUS_OK or some error status
 */
mqtt_status_t mqtt_publish(struct mqtt_connection *conn,
                           uint16_t *mid,
                           char *topic,
                           uint8_t *payload,
                           uint32_t payload_size,
                           mqtt_qos_level_t qos_level,
                           mqtt_retain_t retain);
----

This function sets clients user name and password to use when connecting to a MQTT broker.

[source, c]
----
/**
 * \brief Set the user name and password for a MQTT client.
 * \param conn A pointer to the MQTT connection.
 * \param username A pointer to the user name.
 * \param password A pointer to the password.
 */
void mqtt_set_username_password(struct mqtt_connection *conn,
                                char *username,
                                char *password);
----

This function sets clients Last Will topic and message (payload).
If the Will Flag is set to 1 (using the function) this indicates that, if the Connect request is accepted, a Will Message MUST be stored on the Server and associated with the Network Connection. The Will Message MUST be published when the Network Connection is subsequently closed

This functionality can be used to get notified that a device has disconnected from the broker.

[source, c]
----
/**
 * \brief Set the last will topic and message for a MQTT client.
 * \param conn A pointer to the MQTT connection.
 * \param topic A pointer to the Last Will topic.
 * \param message A pointer to the Last Will message (payload).
 * \param qos The desired QoS level.
 */
void mqtt_set_last_will(struct mqtt_connection *conn,
                        char *topic,
                        char *message,
                        mqtt_qos_level_t qos);
----

The following helper functions can be ussed to assert the MQTT connection status, to check if the mote is connected to the broker with `mqtt_connected`, and with `mqtt_ready` if the connection is estabished and there is space in the buffer to publish.

[source, c]
----
#define mqtt_connected(conn) \
  ((conn)->state == MQTT_CONN_STATE_CONNECTED_TO_BROKER ? 1 : 0)

#define mqtt_ready(conn) \
  (!(conn)->out_queue_full && mqtt_connected((conn)))
----

==== Hands on: MQTT and mosquitto

Now let's build a simple example using http://mosquitto.org/[mosquitto] MQTT broker v.3.1 running in our host as a MQTT Broker, in the following setup:

.MQTT with Mosquitto
image::images/5/image003.png[]

The mosquitto installation is quite straightforward, the installation instructions are available in the http://mosquitto.org/2013/01/mosquitto-debian-repository/[mosquitto website].  For this example we use the default configurations.

Instructions to compile the Border Router are available in previous sections.

We will use the example available at `examples/cc2538dk/mqtt-demo`.  With minor tweaks (like removing the cc2538-specific code) it should also work for the *Z1 mote*.

The example is heavily based on the IBM quickstart format, alternatively it can be built to be used with IBM quickstart.  For more information about this check out the `README` file, or read the https://docs.internetofthings.ibmcloud.com/messaging/applications.html[IBM MQTT doc].

In the `project-conf.h` file the IPv6 broker address is defined as follows:

[source, c]
----
#define MQTT_DEMO_BROKER_IP_ADDR "aaaa::1"
----

As default the `mosquitto` broker binds to the IPv4//IPv6 address of the host, if using the `tunslip6` script with the `aaaa::1/64` address, it should match the `MQTT_DEMO_BROKER_IP_ADDR` definition.

[TIP]
====
Remember that some examples are meant as platform specific, so you should check if there is a `Makefile.target` predefined, or if the `TARGET` is defined elsewhere.
====

The example does the following:

* Publish information to an MQTT broker.
* Subscribe to a topic and receive commands from an MQTT broker.

Note also the `PUBLISH_TRIGGER` is mapped to the user button, it can be used to trigger a publish event.

The data structure for the MQTT client configuration is declared as:

[source, c]
----
typedef struct mqtt_client_config {
  char org_id[CONFIG_ORG_ID_LEN];                 <1>
  char type_id[CONFIG_TYPE_ID_LEN];               <2>
  char auth_token[CONFIG_AUTH_TOKEN_LEN];         <3>
  char event_type_id[CONFIG_EVENT_TYPE_ID_LEN];   <4>
  char broker_ip[CONFIG_IP_ADDR_STR_LEN];         <5>
  char cmd_type[CONFIG_CMD_TYPE_LEN];             <6>
  clock_time_t pub_interval;                      <7>
  int def_rt_ping_interval;                       <8>
  uint16_t broker_port;                           <9>
} mqtt_client_config_t;
----
<1> Unique organization ID
<2> Device type
<3> Authorization token (if required)
<4> Default event type
<5> Broker IPv6 address
<6> Default command type
<7> Publish interval period
<8> Periodically ping the parent and retrieve RSSI value
<9> Broker default port, default is `1883`

Later defined and populate as follows:

[source, c]
----
static mqtt_client_config_t conf;

static int
init_config()
{
  /* Populate configuration with default values */
  memset(&conf, 0, sizeof(mqtt_client_config_t));
  memcpy(conf.org_id, DEFAULT_ORG_ID, strlen(DEFAULT_ORG_ID));
  memcpy(conf.type_id, DEFAULT_TYPE_ID, strlen(DEFAULT_TYPE_ID));
  memcpy(conf.auth_token, DEFAULT_AUTH_TOKEN, strlen(DEFAULT_AUTH_TOKEN));
  memcpy(conf.event_type_id, DEFAULT_EVENT_TYPE_ID,
         strlen(DEFAULT_EVENT_TYPE_ID));
  memcpy(conf.broker_ip, broker_ip, strlen(broker_ip));
  memcpy(conf.cmd_type, DEFAULT_SUBSCRIBE_CMD_TYPE, 1);
  conf.broker_port = DEFAULT_BROKER_PORT;
  conf.pub_interval = DEFAULT_PUBLISH_INTERVAL;
  conf.def_rt_ping_interval = DEFAULT_RSSI_MEAS_INTERVAL;
  return 1;
}
----

The application example itself can be understood as a finite state machine, despise it seems complicated it is actually very straightforward.  The `mqtt_demo_process` starts as follows:

[source, c]
----
PROCESS_THREAD(mqtt_demo_process, ev, data)
{
  PROCESS_BEGIN();

  if(init_config() != 1) {                                          <1>
    PROCESS_EXIT();
  }

  update_config();                                                  <2>

  uip_icmp6_echo_reply_callback_add(&echo_reply_notification,       <3>
                                    echo_reply_handler);
  etimer_set(&echo_request_timer, conf.def_rt_ping_interval);       <4>

  while(1) {

    PROCESS_YIELD();

    if(ev == sensors_event && data == PUBLISH_TRIGGER) {            <5>
      if(state == STATE_ERROR) {
        connect_attempt = 1;
        state = STATE_REGISTERED;
      }
    }

    if((ev == PROCESS_EVENT_TIMER && data == &publish_periodic_timer) ||
       ev == PROCESS_EVENT_POLL ||
       (ev == sensors_event && data == PUBLISH_TRIGGER)) {          <6>
      state_machine();
    }

    if(ev == PROCESS_EVENT_TIMER && data == &echo_request_timer) {  <7>
      ping_parent();
      etimer_set(&echo_request_timer, conf.def_rt_ping_interval);
    }
  }

  PROCESS_END();
}
----
<1> Initial configuration values, as described earlier
<2> Creates the client ID, publish and subscribe topics.  The initial state `STATE_INIT` is set and the `publish_periodic_timer` event is scheduled
<3> Registers the event callback used when a ping event occurs
<4> Starts the periodic ping timer
<5> Allows to try and recover from `STATE_ERROR` by pressing the user button
<6> Handles the `publish_periodic_timer` and button events, this is where the application actually starts
<7> When the periodic ping timer expires, pings the parent

When the `construct_client_id` is first called with the `STATE_INIT`, the `state_machine` is called.  A brief walkthrough of the state machine is shown next.  Notice how in some events (like `STATE_INIT`) immediately the driver jumps to the next events as there is not a `break` statement.

[source, c]
----
static void
state_machine(void)
{
  switch(state) {

  case STATE_INIT:                  <1>
    /* If we have just been configured register MQTT connection */
    mqtt_register(&conn, &mqtt_demo_process, client_id, mqtt_event,
                  MAX_TCP_SEGMENT_SIZE);
    state = STATE_REGISTERED;

  case STATE_REGISTERED:            <2>
    if(uip_ds6_get_global(ADDR_PREFERRED) != NULL) {
      connect_to_broker();
    } else {
      leds_on(STATUS_LED);
      ctimer_set(&ct, NO_NET_LED_DURATION, publish_led_off, NULL);
    }
    etimer_set(&publish_periodic_timer, NET_CONNECT_PERIODIC);
    return;
    break;

  case STATE_CONNECTING:            <3>
    leds_on(STATUS_LED);
    ctimer_set(&ct, CONNECTING_LED_DURATION, publish_led_off, NULL);
    /* Not connected yet. Wait */
    DBG("Connecting (%u)\n", connect_attempt);
    break;

  case STATE_CONNECTED:             <4>
    /* Don't subscribe unless we are a registered device */
    if(strncasecmp(conf.org_id, QUICKSTART, strlen(conf.org_id)) == 0) {
      DBG("Using 'quickstart': Skipping subscribe\n");
      state = STATE_PUBLISHING;
    }

  case STATE_PUBLISHING:            <5>
    /* If the timer expired, the connection is stable. */
    if(timer_expired(&connection_life)) {
      /*
       * Intentionally using 0 here instead of 1: We want RECONNECT_ATTEMPTS
       * attempts if we disconnect after a successful connect
       */
      connect_attempt = 0;
    }

    if(mqtt_ready(&conn) && conn.out_buffer_sent) {
      /* Connected. Publish */
      if(state == STATE_CONNECTED) {
        subscribe();
        state = STATE_PUBLISHING;
      } else {
        leds_on(STATUS_LED);
        ctimer_set(&ct, PUBLISH_LED_ON_DURATION, publish_led_off, NULL);
        publish();
      }
      etimer_set(&publish_periodic_timer, conf.pub_interval);
      return;
    } else {
      /*
       * Our publish timer fired, but some MQTT packet is already in flight
       * (either not sent at all, or sent but not fully ACKd).
       *
       * This can mean that we have lost connectivity to our broker or that
       * simply there is some network delay. In both cases, we refuse to
       * trigger a new message and we wait for TCP to either ACK the entire
       * packet after retries, or to timeout and notify us.
       */
    }
    break;

  case STATE_DISCONNECTED:          <6>
    DBG("Disconnected\n");
    if(connect_attempt < RECONNECT_ATTEMPTS ||
       RECONNECT_ATTEMPTS == RETRY_FOREVER) {
      /* Disconnect and backoff */
      clock_time_t interval;
      mqtt_disconnect(&conn);
      connect_attempt++;

      interval = connect_attempt < 3 ? RECONNECT_INTERVAL << connect_attempt :
        RECONNECT_INTERVAL << 3;

      DBG("Disconnected. Attempt %u in %lu ticks\n", connect_attempt, interval);

      etimer_set(&publish_periodic_timer, interval);

      state = STATE_REGISTERED;
      return;
    } else {
      /* Max reconnect attempts reached. Enter error state */
      state = STATE_ERROR;
      DBG("Aborting connection after %u attempts\n", connect_attempt - 1);
    }
    break;

  case STATE_CONFIG_ERROR:        <7>
    /* Idle away. The only way out is a new config */
    printf("Bad configuration.\n");
    return;

  case STATE_ERROR:               <8>
  default:
    leds_on(STATUS_LED);
    /*
     * 'default' should never happen.
     *
     * If we enter here it's because of some error. Stop timers. The only thing
     * that can bring us out is a new config event
     */
    printf("Default case: State=0x%02x\n", state);
    return;
  }

  /* If we didn't return so far, reschedule ourselves */
  etimer_set(&publish_periodic_timer, STATE_MACHINE_PERIODIC);
}
----
<1> Entry point, register the mqtt connection and move to the `STATE_REGISTERED` event
<2> Attempts to connect to the broker.  If the node has not joined the network (doesn't have a valid IPv6 global address) it retries later.  If the node has a valid address then calls the `mqtt_connect` function and sets the state to `STATE_CONNECTING`, then sets the `publish_periodic_timer` with a faster pace
<3> This event just informs the user about the connection attemps.  When the MQTT connection to the broker has been made, the `MQTT_EVENT_CONNECTED` is triggered at the `mqtt_event` callback handler
<4> As we are connected now, proceed and publish.  As we should not be using IBM's quickstart, we skip changing the state to `STATE_PUBLISHING` and just go ahead
<5> Checks if the MQTT connection is OK in `mqtt_ready`, then subscribe and publish
<6> Handles any disconnection event triggered from `MQTT_EVENT_DISCONNECTED`
<7> Halts the application, only allows valid configuration values
<8> Default event handler, stops the timer and do nothing

The `publish` function create the string data to be published.  Below is a snippet of the function highlighting only the most relevant parts.  The example publish periodically the following:

* Device name.
* An incremental sequence number.
* Device uptime (in seconds).
* On-chip temperature.
* Battery value.

[source, c]
----
static void
publish(void)
{
  len = snprintf(buf_ptr, remaining,
                 "{"
                 "\"d\":{"
                 "\"myName\":\"%s\","
                 "\"Seq #\":%d,"
                 "\"Uptime (sec)\":%lu",
                 BOARD_STRING, seq_nr_value, clock_seconds());

  len = snprintf(buf_ptr, remaining, ",\"Def Route\":\"%s\",\"RSSI (dBm)\":%d",
                 def_rt_str, def_rt_rssi);

  len = snprintf(buf_ptr, remaining, ",\"On-Chip Temp (mC)\":%d",
                 cc2538_temp_sensor.value(CC2538_SENSORS_VALUE_TYPE_CONVERTED));

  len = snprintf(buf_ptr, remaining, ",\"VDD3 (mV)\":%d",
                 vdd3_sensor.value(CC2538_SENSORS_VALUE_TYPE_CONVERTED));

  mqtt_publish(&conn, NULL, pub_topic, (uint8_t *)app_buffer,
               strlen(app_buffer), MQTT_QOS_LEVEL_0, MQTT_RETAIN_OFF);

  DBG("APP - Publish!\n");
}
----

The `mqtt_publish` updates the MQTT broker with the new values, publishing to the specified `pub_topic`.  The default topic is `iot-2/evt/status/fmt/json` as done in the `construct_pub_topic` function.  This topic follows IBM's format but it can be otherwise changed accordingly.

When receiving an event from a topic we are subscribed to, the `MQTT_EVENT_PUBLISH` event is triggered and the `pub_handler` is called.  The example allows to turn the red LED on and off alternatively.

The default topic the example subscribe to is `iot-2/cmd/+/fmt/json`, specifically to change the LED status we would need to publish to the `iot-2/cmd/leds/fmt/json` topic with value `1` to turn the LED on, and `0` otherwise.

[source, c]
----
static void
pub_handler(const char *topic, uint16_t topic_len, const uint8_t *chunk,
            uint16_t chunk_len)
{
  if(strncmp(&topic[10], "leds", 4) == 0) {
    if(chunk[0] == '1') {
      leds_on(LEDS_RED);
    } else if(chunk[0] == '0') {
      leds_off(LEDS_RED);
    }
    return;
  }
}
----

Note the `+` in the subscribed topic, this allows to have different subsets of topics, such as `leds`.


=== Hands on: connecting to a real world IoT platform (HTTP-based)

Ubidots (www.ubidots.com) is an IoT cloud platform Ubidots that helps you create applications that capture
 real-world data and turn it into meaningful actions and insights.

=== Ubidots IPv6 example in native Contiki

The example will demonstrate the basic functionality of Contiki's Ubidots library:

* How to use the library to POST to a variable.
* How to use the library to POST to a collection.
* How to receive (parts of) the HTTP reply.

At the present time the Ubidots example was to be merged to Contiki, however the functional
example can be browsed and forked from the following:

https://github.com/g-oikonomou/contiki/tree/ubidots-demo

The Contiki's Ubidots Library was written by George Oikonomou.

The Ubidots example is located at `examples/ipv6/ubidots`.

Ubidots application is implemented at `apps/ubidots`.

Ubidots application uses TCP sockets to connect to the host `things.ubidots.com`, which has the following IPv4 and IPv6 endpoints:

.Ubidots endpoint IPv4/IPv6 addresses
image::./images/5/image004.png[]

To check what's going on enable the debug print statements in the `ubidots.c` file, search for `#define DEBUG DEBUG_NONE` and replace with:

[source, c]
----
#define DEBUG DEBUG_PRINT
----

As default the `ubidots` application uses the `things.ubidots.com` remote host, however if no NAT/NAT64 service is available to resolve the host address, the IPv6 endpoint can be explicitly defined as:

[source, c]
----
#define UBIDOTS_CONF_REMOTE_HOST "2607:f0d0:2101:39::2"
----

[TIP]
====
If you don't have a local IPv6 connection, services like http://www.gogo6.com/[gogo6] and https://ipv6.he.net/[hurricane electric] provides IPv6 tunnels over IPv4 connections.  Other options like http://www.wrapsix.org/[wrapsix] allows to have NAT64 to translate IPv6/IPv4 addresses.
====

The Ubidots demo posts every 30 seconds the Z1 mote's *uptime* and *sequence number*, so as done before in the past sections we need to create these two variables at Ubidots.  Create the data source, its variables and then open `project-conf.h` file and replace the following accordingly:

[source, c]
----
#define UBIDOTS_DEMO_CONF_UPTIME       "XXXX"
#define UBIDOTS_DEMO_CONF_SEQUENCE     "XXXX"
----

The last step is to assign an Ubidot's fixed Short Token so we don't have to request one from time to time when it expires, get one and add this to the `Makefile`, the file should look like this:

[source, c]
----
DEFINES+=PROJECT_CONF_H=\"project-conf.h\"
CONTIKI_PROJECT = ubidots-demo
APPS = ubidots
UBIDOTS_WITH_AUTH_TOKEN=XXXXXXXX
ifdef UBIDOTS_WITH_AUTH_TOKEN
  DEFINES+=UBIDOTS_CONF_AUTH_TOKEN=\"$(UBIDOTS_WITH_AUTH_TOKEN)\"
endif
all: $(CONTIKI_PROJECT)
CONTIKI_WITH_IPV6 = 1
CONTIKI = ../../..
include $(CONTIKI)/Makefile.include
----

Note that you should replace the `UBIDOTS_WITH_AUTH_TOKEN` *without using ""* quotes.

Now everything should be set, let's compile and program a Z1 mote!

[source, bash]
----
make TARGET=z1 savetarget
make clean && make ubidots-demo.upload && make z1-reset && make login
----

You should see the following output:

[source, bash]
----
connecting to /dev/ttyUSB0 (115200) [OK]
Rime started with address 193.12.0.0.0.0.0.158
MAC c1:0c:00:00:00:00:00:9e Ref ID: 158
Contiki-d368451 started. Node id is set to 158.
nullmac nullrdc, channel check rate 128 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
Starting 'Ubidots demo process'
Ubidots client: STATE_ERROR_NO_NET
Ubidots client: STATE_ERROR_NO_NET
Ubidots client: STATE_ERROR_NO_NET
Ubidots client: STATE_STARTING
Ubidots client: Checking 64:ff9b::3217:7c44
Ubidots client: 'Host: [64:ff9b::3217:7c44]' (remaining 44)
Ubidots client: STATE_TCP_CONNECT (1)
Ubidots client: Connect 64:ff9b::3217:7c44 port 80
event_callback: connected
Ubidots client: STATE_TCP_CONNECTED
Ubidots client: Prepare POST: Buffer at 199
Ubidots client: Enqueue value: Buffer at 210
Ubidots client: POST: Buffer at 211, content-length 13 (2), at 143
Ubidots client: POST: Buffer at 208
Ubidots client: STATE_POSTING (176)
Ubidots client: STATE_POSTING (176)
Ubidots client: STATE_POSTING (144)
Ubidots client: STATE_POSTING (112)
Ubidots client: STATE_POSTING (80)
Ubidots client: STATE_POSTING (48)
Ubidots client: STATE_POSTING (16)
Ubidots client: STATE_POSTING (0)
Ubidots client: HTTP Reply 200
HTTP Status: 200
Ubidots client: New header: <Server: nginx>
Ubidots client: New header: <Date: Fri, 13 Mar 2015 09:35:08 GMT>
Ubidots client: New header: <Content-Type: application/json>
Ubidots client: New header: <Transfer-Encoding: chunked>
Ubidots client: New header: <Connection: keep-alive>
Ubidots client: New header: <Vary: Accept-Encoding>
Ubidots client: Client wants header 'Vary'
H: 'Vary: Accept-Encoding'
Ubidots client: New header: <Vary: Accept>
Ubidots client: Client wants header 'Vary'
H: 'Vary: Accept'
Ubidots client: New header: <Allow: GET, POST, HEAD, OPTIONS>
Ubidots client: Chunk, len 22: <[{"status_code": 201}]> (counter = 22)
Ubidots client: Chunk, len 0: <(End of Reply)> (Payload Length 22 bytes)
P: '[{"status_code": 201}]'
----

.Ubidots graphs
image::./images/5/image005.png[scaledwidth="75%"]

The values are displayed using a *Multi-line chart* and a *Table-Values* dashboard.
