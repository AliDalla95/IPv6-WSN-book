
== Introduction to Contiki

Contiki is an open source operating system for the Internet of Things, it connects tiny low-cost, low-power microcontrollers to the Internet.

Contiki provides powerful low-consumption Internet communication, it supports fully standard IPv6 and IPv4, along with the recent low-power wireless standards: 6lowpan, RPL, CoAP. With Contiki's ContikiMAC and sleepy routers, even wireless routers can be battery-operated.

With Contiki, development is easy and fast: Contiki applications are written in standard C, with the Cooja simulator Contiki networks can be emulated before burned into hardware, and Instant Contiki provides an entire development environment in a single download.

Visit the http://contiki-os.org[Contiki OS site] for more information.

The remainder of the chapter intends to be a thoughtful introduction to Contiki 3.0, its core components and features.  The following references are the must-go places to search for detailed information:

* https://github.com/contiki-os/contiki/wiki[The Contiki wiki page]
* http://sourceforge.net/p/contiki/mailman/contiki-developers[The Contiki mailing list]
* https://github.com/Zolertia/Resources/wiki[Zolertia Wiki page]


=== Install Contiki

There are several ways to install Contiki, from scratch by installing from sources or using
virtual environments, depending on the flavour and time availability.

To work with Contiki you will need three items:

* The Contiki source code.
* A target platform (virtual platform or a real hardware one).
* A toolchain to compile the source code for such target platform.

The remainder of the book assumes Contiki will run in an Unix environment,
as the virtualized environments run on Ubuntu.

==== Install from sources

Contiki source code is actively supported by contributors from universities, research centers and developers from all over the world.  

The source code is hosted at https://github.com/contiki-os/contiki[Contiki GitHub repository]:

To grab the source code open a terminal and execute the following:

[source, bash]
----
sudo apt-get -y install git
git clone --recursive https://github.com/contiki-os/contiki.git
----

.What is git?
****

*Git* is a free and open source distributed version control system, designed for speed and efficiency.

The main difference with other change control tools is the possibility to work locally since your local copy is a repository, and you can commit to it and get all benefits of source control.

There are some great tutorials online to learn more about git:

* http://try.github.io[Code School & GitHub "try Git"]

* http://rogerdudler.github.io/git-guide/[Roger Dudler's Git simple guide]

*GitHub* is a GIT repository web-based hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git as well as adding its own features. GitHub provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, bug tracking and feature requests for every project.

The advantage of using GIT and hosting the code at github is that of allowing people to fork the code, further develop it, and then contribute back to share their improvements.

****

To install the toolchain and required dependencies, run in a terminal the following:

[source, bash]
----
sudo apt-get update
sudo apt-get install gcc-arm-none-eabi gdb-arm-none-eabi
sudo apt-get -y install build-essential automake gettext
sudo apt-get -y install gcc-arm-none-eabi curl graphviz unzip wget
sudo apt-get -y install gcc gcc-msp430
sudo apt-get -y install openjdk-7-jdk openjdk-7-jre ant
----

This will install support for the ARM Cortex-M3 and MSP430 platforms, as well as
support for Cooja, the Contiki's emulator to be discussed in the next sections.

==== Instant Contiki Virtual Machine

Instant Contiki is an entire Contiki development environment in a single download. It is an Ubuntu Linux virtual machine and has Contiki OS and all the development tools, compilers, and simulators required already pre-installed.

Grab Instant Contiki from the Contiki website:

http://www.contiki-os.org/start.html

The latest Instant Contiki release is 3.0, following the Contiki 3.0 source code release.

This book is heavily based on this release, the use of earlier versions is not recommended.

The release tag is available at:

https://github.com/contiki-os/contiki/tree/release-3-0

Nevertheless you should use the latest commit available, as Contiki releases are produced on a yearly base.  Many bug fixes, new features and improved support is normally present on the latest `master` branch.

[NOTE]
====
At the moment of this release, the current Contiki commit corresponds to the `daa83ee3ef32f5b48f647e1c614fe6523ab440bb` HASH.  You can use the following GIT command to place yourself on this commit:

`git checkout daa83ee3ef32f5b48f647e1c614fe6523ab440bb`

As Contiki ensures the platform and application support by using a strict code revision procedure and regression tests, this is a safe point if you encounter any problem.  Be sure to update your Contiki local repository if using `Instant Contiki`!
====

Download https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0[VMWare player for Windowws and Linux] to run Contiki's virtual machine, it is free and widely used.

In OSX you can download http://www.vmware.com/products/fusion[VMWare Fusion]

Using VMWare just open the `Instant_Contiki_Ubuntu_12.04_32-bit.vmx` file, if prompted about the VM source just choose `I copied it` then wait for the virtual Ubuntu Linux boot up.

Log into Instant Contiki. The password and user name is `user`. Don’t upgrade right now.

Remember to update the Contiki repository and get the latest upgrades:

[source,bash]
----
cd /home/user/contiki
git fetch origin
git pull origin master
----

=== Test Contiki installation

Let us first check the toolchain installation.  The MSP430 toolchain can be tested with:

[source, bash]
----
msp430-gcc --version
msp430-gcc (GCC) 4.7.0 20120322 (mspgcc dev 20120716)
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----

And for the ARM Cortex-M3 toolchain:

[source, bash]
----
arm-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]  
Copyright (C) 2014 Free Software Foundation, Inc.  
This is free software; see the source for copying conditions.  There is NO  
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----


=== Contiki structure

Contiki has the following file structure:

[width="100%",options="header,footer"]
|=======================================================================
|Folder    | Description | Zolertia files
|examples  | Ready to build examples | examples/zolertia, examples/cc2538-common
|app       | Contiki applications | -
|cpu       | Specific MCU files | msp430, cc2538
|dev       | External chip and devices | cc2420, cc1200
|platform  | Specific files and platform drivers | z1, zoul
|core      | Contiki core files and libraries | -
|tools     | Tools for flashing, debuging, simulating, etc. | zolertia, sky
|doc       | Self-generated doxygen documentation | -
|regression-tests  |nightly regression tests | -
|=======================================================================

In the following sections we will cover the examples and specific platform files for the Zolertia platforms.

=== Run Contiki on real hardware

For the remainder of the book we will use Zolertia Z1 and RE-Mote hardware development platforms. Other platforms can be used as well, but are out of the scope of this book.

Contiki drivers and libraries are (normally) platform independent, most examples can be run in both Z1 and RE-Mote platforms by taking into consideration specific platform settings.

There are platform-specific examples for the Z1 platform at `examples/zolertia/z1`, and at `examples/zolertia/zoul` for the RE-Mote.  Additionaly `CC2538` specific examples can be found at `examples/cc2538-common`.  This folder has CC2538 ARM Cortex-M3 related examples and applications.

More information about both platforms and updates guides can be found at:

* http://www.zolertia[Zolertia website]
* https://github.com/Zolertia/Resources/wiki/RE-Mote[Zolertia RE-Mote wiki page]
* https://github.com/Zolertia/Resources/wiki#the-z1-mote[Zolertia Z1 wiki page]

==== Zolertia Zoul module and the RE-Mote development platform

The **Zoul** is a module based in the CC2538 ARM Cortex-M3 system on chip (SoC), with an on-board 2.4 GHz IEEE 802.15.4 RF interface, running at up to 32 MHz with 512 kB of programmable flash and 32 kB of RAM, bundled with a CC1200 868/915 MHz RF transceiver to allow dual band operation.

The Zoul allows fast reusability on designs and quick scaling from prototyping to production.

.Zolertia Zoul module and the RE-Mote platform
image::./images/3/image001.jpg[align="center"]


The **RE-Mote** has a Zoul on board and also packs:

*   ISM 2.4-GHz IEEE 802.15.4 & Zigbee compliant radio.
*   ISM 863-950-MHz ISM/SRD band radio.
*   AES-128/256, SHA2 Hardware Encryption Engine.
*   ECC-128/256, RSA Hardware Acceleration Engine for Secure Key Exchange.
*   Consumption down to 150 nA using the shutdown mode.
*   Programming over BSL without requiring to press any button to enter bootloader mode.
*   Built-in battery charger (500 mA), facilitating Energy Harvesting and direct connection to Solar Panels and to standards LiPo batteries.
*   Wide range DC Power input: 2-16 V.
*   Small form-factor.
*   MicroSD over SPI.
*   On board RTC (programmable real time clock) and external watchdog timer (WDT).
*   Programmable RF switch to connect an external antenna either to the 2.4 GHz or to the Sub 1 GHz RF interface through the RP-SMA connector.

The **RE-Mote** has been developed jointly with universities and industrial partners in the frame of the European research project **RERUM**(**RERUM: REliable, Resilient and secUre IoT for sMart city applications**).


==== Zolertia Z1 mote

The *Z1 mote* features a second generation MSP430F2617 low power 16-bit RISC CPU @ 16 MHz MCU, 8 kB RAM and a 92 kB Flash memory. It includes the well known CC2420 transceiver, IEEE 802.15.4 compliant, which operates at 2.4 GHz with an effective data rate of 250 kbps.

.Zolertia Z1 mote
image::./images/3/image002.png[align="center"]

The Zolertia Z1 mote can run TinyOS, Contiki OS, OpenWSN and RIOT, and has been used actively for over 5 years in universities, research and development centers and in commercial products in more than 43 countries, being featured in more than 50 scientific publications.

The Z1 mote is fully emulated in both MSPSIM and Cooja.


==== What are the differences between the RE-Mote and the Z1 platforms?

In a nutshell: power and coolness.

The RE-Mote has 4 times more RAM than the Z1 mote, 5 times more flash memory, twice the frequency of operation and 120 times less power consumption in its lowest power mode (shutdown mode). 

Another major difference is that (at the time of writing this book) the Z1 mote is supported by Cooja, the Contiki emulator, while the RE-Mote is not.  However efforts are on going to provide emulation framework support in the http://emul8.org/[EMUL8] project.

To check in depth the differences between the RE-Mote and the Z1 mote, and also obtain guidelines to port applications developed for the Z1 to the RE-Mote, visit the https://github.com/Zolertia/Resources/wiki/Migrate-From-Z1-to-RE-Mote["Migrate from Z1 to RE-Mote" wiki page].


=== Start with Contiki!

Let's compile our first Contiki example! Open a terminal and write:

[source, bash]
----
cd examples/hello-world
make TARGET=zoul savetarget
----

This will tell Contiki to compile the hello world example for the RE-Mote platform from now on.  Alternatively, to use the Z1 mote instead, just run:

[source, bash]
----
make TARGET=z1 savetarget
----

You need to do this only once per application.  Not let's compile the application:

[source, bash]
----
make hello-world
----

To start compiling the code (ignore the warnings), if everything works OK you should see something like:

[source, bash]
----
CC        symbols.c
AR        contiki-z1.a
CC        hello-world.c
CC        ../../platform/z1/./contiki-z1-main.c
LD        hello-world.z1
rm obj_z1/contiki-z1-main.o hello-world.co
----
The `hello-world.z1` file should have been created and we are ready to flash the application to the device.

At any given point you can override the saved target and redefine at compilation time by running instead:

[source, bash]
----
make TARGET=zoul hello-world
  CC        hello-world.c
  LD        hello-world.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff hello-world.elf hello-world.bin
----

This will ignore the saved `Makefile.target` file and use the target `zoul` instead.

In the following sections and chapters the examples can be compiled for both the Z1 and RE-Mote platform, unless specified otherwise.

[NOTE]
====
The RE-Mote takes two arguments: `TARGET` and `BOARD`, while the Z1 mote only uses the first one with the `z1` string as noted before.  For the RE-Mote, `TARGET` is always `zoul` and `BOARD` is `remote`, but when compiling, if the `BOARD` flag is not explicitly defined, it will default to `remote`.  This approach is because there are other Zoul based platforms which share the same code base and modules, but the RE-Mote has its own specific platform files and definitions.
====

==== Hello world explained

Let’s see the main components of the Hello World example.  Browse the code with:

[source, bash]
----
gedit hello-world.c
----

Or your preferred text editor.

When starting Contiki, you declare processes with a name. In each code you can have several processes.  You declare the process like this:

[source, c]
----
PROCESS(hello_world_process, "Hello world process"); // <1>
AUTOSTART_PROCESSES(&hello_world_process); // <2>
----
<1> `hello_world_process` is the name of the process and
`"Hello world process"` is the readable name of the process when you print it to the terminal.
<2> The `AUTOSTART_PROCESSES(&hello_world_process)` tells Contiki to start that process when it finishes booting.

[source, c]
----
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data) <1>
{
  PROCESS_BEGIN(); <2>
  printf("Hello, world\n"); <3>
  PROCESS_END(); <4>
}
----
<1> You declare the content of the process in the process thread. You have the name of the process and callback functions (event handler and data handler).
<2> Inside the thread you begin the process,
<3> do what you want and
<4> finally end the process.

==== Makefile explained

Applications require a Makefile to compile, let us take a look at the `hello-world` Makefile:

[source, bash]
----
CONTIKI_PROJECT = hello-world        <1>
all: $(CONTIKI_PROJECT)              <2>
CONTIKI = ../..                      <3> 
include $(CONTIKI)/Makefile.include  <4>
----
<1> Tells the build system which application to compile
<2> If using `make all` it will compile the defined applications
<3> Specify our indentation level respect to Contiki root folder
<4> The system-wide Contiki Makefile, also points out to the platform's Makefile

We can define specific compilation flags in the Makefile, although the 
recommended way would be to add a `project-conf.h` header, and define there
any compilation flag or value.  This is done by adding this to the Makefile:

[source, bash]
----
DEFINES+=PROJECT_CONF_H=\"project-conf.h\"
----

And then creating a `project-conf.h` header file in the example location.

[TIP]
====
Before you embark in Contiki, it is useful to remember that normally the drivers have a switch like:

[source, c]
----
#define DEBUG 0
#if DEBUG
#define PRINTF(...) printf(__VA_ARGS__)
#else
#define PRINTF(...)
#endif
----

Enable the `DEBUG` by changing to `1` or `DEBUG_PRINT`, this will print debug information to the console.  Normally you should do it in every driver file you wish to debug.
====

==== Adding an LED to the example

The next step is adding an LED (light emitting diode) to interact with our application.

You have to add the `dev/leds.h` which is the library to manage the LEDs.  To check the available functions go to `core/dev/leds.h`.

Available LEDs commands:

[source, c]
----
unsigned char leds_get(void);
void leds_set(unsigned char leds);
void leds_on(unsigned char leds);
void leds_off(unsigned char leds);
void leds_toggle(unsigned char leds);
----

Normally all platforms comply to the following available LEDs:

[source, c]
----
LEDS_GREEN
LEDS_RED
LEDS_BLUE
LEDS_ALL
----

In the Z1 mote these LEDs are defined in `platform/z1/platform-conf.h`, as well as other hardware definitions.

The RE-Mote uses an RGB LED, basically 3-channel LEDs in a single device, allowing to show any color by the proper combination of Blue, Red and Green. In `platforms/zoul/remote/board.h` header the following are defined:

[source, c]
----
LEDS_LIGHT_BLUE
LEDS_YELLOW
LEDS_PURPLE
LEDS_WHITE
----

Now try to turn on only the red LED and see what happens, create a new example named `test-leds.c`:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(test_leds_process, "Test LEDs");
AUTOSTART_PROCESSES(&test_leds_process);
/*-------------------------------------------------*/
PROCESS_THREAD(test_leds_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  PROCESS_END();
}
----

Now let’s compile and upload the new project with:

[source, bash]
----
make clean && make test-leds.upload
----

The `make clean` command is used to erase previously compiled objects.

Now the red LED should be on!

[CAUTION]
====
If you make changes to the source code, you must rebuild the files, otherwise your change might not be pulled in. It is always recommended to do a `make clean` command before compiling.
====

TIP: Exercise: try to switch on the other LEDs.

==== Printing messages to the console

You can use printf to visualize on the console what is happening in your application.  It is really useful to debug your code, as you can print values of variables, when certain block of code is being executed, etc.

Let’s try to print the status of the LED, using the `unsigned char leds_get(void);` function that is available in the documented functions (see above).

Get the LED status and print it on the screen, modify the current `test-leds.c` file as follows:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
char hello[] = "hello from the mote!";
/*-------------------------------------------------*/
PROCESS(test_leds_process, "Test LEDs");
AUTOSTART_PROCESSES(&test_leds_process);
/*-------------------------------------------------*/
PROCESS_THREAD(test_leds_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  printf("%s\n", hello);
  printf("The LED %u is %u\n", LEDS_RED, leds_get());
  PROCESS_END();
}
----

If one LED is on, you will get the LED number, which is defined by each platform in its `platform-conf.h` or `board.h` header.

TIP: Exercise: what happens when you turn on more than one LED? What number do you get? are these the same numbers for the Z1 and the RE-Mote?

==== Adding button events

We now want to detect if the *user button* has been pressed.

The button in Contiki is regarded as a sensor. We are going to use the `core/dev/button-sensor.h` library.

TIP: The RE-Mote platform has extra button functionalities, such as detect long-press sequences, enabling to further expand the events that can be triggered using the button.  Check `platform/zoul/dev/button-sensor.c` for more details, and `examples/zolertia/zoul/zoul-demo.c` for an example.

Create a new example called `test-button.c` and add the `dev/button-sensor.h` header and button event as follows:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(test_button_process, "Test button");
AUTOSTART_PROCESSES(&test_button_process);
/*-------------------------------------------------*/
PROCESS_THREAD(test_button_process, ev, data)
{
  PROCESS_BEGIN();
  SENSORS_ACTIVATE(button_sensor);
  while(1) {
    PROCESS_WAIT_EVENT_UNTIL((ev==sensors_event) &&
                            (data == &button_sensor));
    printf("I pushed the button!\n");
  }
  PROCESS_END();
}
----

This process has an infinite loop, given by the `wait()`, to wait for the button the be pressed.  The two conditions have to be met (event from a sensor and that event is the button being pressed), as soon as you press the button, you get the string printed.

TIP: Exercise: switch on the LED when the button is pressed. Switch off the LED when the button is pressed again.

==== Timers

Using timers will allow us to trigger events at a given time, speeding up the transition from one state to another and automating a given process or task, for example blinking an LED every 5 seconds, without the user having to press the button each time.

Contiki OS provides 4 kind of timers:

* Simple timer: A simple ticker, the application should check _manually_ if the timer has expired.  More information at `core/sys/timer.h`.
* Callback timer: When a timer expires it can callback a given function. More information at `core/sys/ctimer.h`.
* Event timer: Same as above, but instead of calling a function, when the timer expires it posts an event signalling its expiration. More information at `core/sys/etimer.h`.
* Real time timer: The real-time module handles the scheduling and execution of real-time tasks, there's only 1 timer available at the moment.  More information at `core/sys/rtimer.h`

For our implementation we are going to choose the event timer, because we want to change the application behavior when the timer expires every given period.

We create a timer structure and set the timer to expire after a given number of seconds. When the timer expires we execute the code and restart the timer.

Create an example called `test-timer.c` as follows:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
/*-------------------------------------------------*/
#define  SECONDS 2
/*-------------------------------------------------*/
PROCESS(test_timer_process, "Test timer");
AUTOSTART_PROCESSES(&test_timer_process);
/*-------------------------------------------------*/
PROCESS_THREAD(test_timer_process, ev, data)
{
  PROCESS_BEGIN();
  static struct etimer et;
  while(1) {
    etimer_set(&et, CLOCK_SECOND*SECONDS); <1>
    PROCESS_WAIT_EVENT(); <2>
    if(etimer_expired(&et)) {
      printf("Hello world!\n");
      etimer_reset(&et);
    }
  }
  PROCESS_END();
}
----
<1> `CLOCK_SECOND` is a value related to the number of the microcontroller's ticks per second. As Contiki runs on different platforms with different hardware, the value of `CLOCK_SECOND` also differs.
<2> `PROCESS_WAIT_EVENT()` waits for _any_ event to happen.

TIP: Exercise: can you print the value of `CLOCK_SECOND` to count how many ticks you have in one second? Try to blink the LED for a certain number of seconds. Make a new application that starts only when the button is pressed and stops when the button is pressed again.


==== Sensors

A sensor is a transducer whose purpose is to sense or detect a characteristic of its environment, providing a corresponding output, generally as an electrical or optical signal, related to the quantity of the measured variable.

Sensors in Contiki are implemented as follow:

[source, c]
----
SENSORS_SENSOR (sensor, SENSOR_NAME, value, configure, status);
----

This means that a method to `configure` the sensor, poll the sensor `status` and request a `value` have to be implemented.  The `sensor` structure contains pointers to these functions.  The arguments for each function are shown below.

[source, c]
----
struct sensors_sensor {
   char *       type;
   int          (* value)     (int type);
   int          (* configure) (int type, int value);
   int          (* status)    (int type);
};
----

To better understand please refer to the `platform/zoul/dev/adc-sensors.c`, for an example of how analogue external sensors can be implemented (to be further discussed in the next sections).

The following functions and macros can be used to work with the sensor:

[source, c]
----
SENSORS_ACTIVATE(sensor)    <1>
SENSORS_DEACTIVATE(sensor)  <2>
sensor.value(type);         <3>
----
<1> Enable the sensor, typically configures and turns the sensor on
<2> Disables the sensor, it is useful to save power
<3> Request a value to the sensor.  As one sensor chip might have different types of readings (temperature, humidity, etc.), this is used to specify which measure to take.

[IMPORTANT]
====
Although this is the default way to implement sensors in Contiki, there might be alternatives, depending on the sensor and developer.  Always check the specific sensor driver implementation for details.  Normally sensors are provided in the same location as the example, in the `dev` folder, or in the `platform/zoul/dev` directory for example.
====

The `SENSORS` macro provides external linkage to the sensors defined for the platform and application, allowing to iterate between the available sensors. The following are the sensors defined as default for the RE-Mote platform:

[source, c]
----
SENSORS (&button_sensor, &vdd3_sensor, &cc2538_temp_sensor, &adc_sensors);
----

[NOTE]
====
The button is considered a sensor in Contiki, and it shares the same sensor implementation
====

This macro extends to:

[source, c]
----
const struct sensors_sensor *sensors[] = {
  &button_sensor,
  &vdd3_sensor,
  &cc2538_temp_sensor,
  &adc_sensors,
  ((void *)0)
};
----

The number of sensors can be found with the `SENSORS_NUM` macro:

[source, c]
----
#define SENSORS_NUM (sizeof(sensors) / sizeof(struct sensors_sensor *))
----

Sensors can be of two types: analogue or digital. In the following sections examples will be shown for both types, detailing how to connect and use both the platform's internal sensors as well as the external ones.

===== Analogue Sensors

****
Analogue sensors typically require being connected to an ADC (analogue to digital converter) to translate the analogue (continuous) reading to an equivalent digital value in millivolts. The quality and resolution of the measure depends on both the ADC resolution (up to 12 bits in the Z1 and RE-Mote) and the sampling frequency.

As a rule of thumb, the sampling frequency must be at least twice that of the phenomenon you are measuring. As an example, if you want to sample human speech (which may contain frequencies up to 8 kHz) you need to sample at twice that frequency (16 kHz).
****

The Z1 mote has a built-in voltage sensor provided as an ADC input channel, as well as a generic implementation to read external analogue sensors.

[TIP]
====
Analogue sensors can be connected to both the Z1 and the RE-Mote over  _phidget_ ports, which are basically 3-pin connectors (Ground, VCC and signal) with 2.54 mm spacing.  This is a legacy name from the Z1 release, as these ports were meant for the commercially available Phidget sensors. Nowadays there are also sensors from other providers, such as seeedstudio that have the same pin-out but with a different pin spacing (2 mm). This is not a problem, as there are cables to adapt the pin spacing.

.Analogue sensors
image::./images/3/image008.jpg[scaledwidth="30", align="center"]

====

The ADC results in the RE-Mote returns the reading in voltage.

For the Z1 mote the ADC output must be converted by means of the following formula: We multiply the measured value by the voltage reference and divide the product by the ADC's maximum output.  As the resolution of the ADC is 12 bits (2^12^ = 4096), we get:

  Voltage, mV = (units * Vref) / 4096;

The voltage reference limits the range of our measure, meaning if we use a `Vref` of 2.5 V, the sensor will saturate when reading a higher voltage.  The reference can be chosen while configuring the ADC, for both the Z1 and RE-Mote normally 3.3 V is used.

Both the Z1 and the RE-Mote allow up to 6 analogue sensors to be connected, but only two _phidget_ connectors can be soldered at the same time.

For the RE-Mote it is possible to have one phidget connector for a 3.3 V analogue sensor (ADC1) and another for 5 V sensors (ADC3).

[TIP]
====
The RE-Mote is based on an ARM Cortex-M3, this allows to map any given pin to a controller (as opposite to the MSP430, for which a pin has predefined functions other than GPIO), but only pins in the PA port can be used as ADC.
====

For the Z1 mote is possible to have the following combinations (see Figure below):

* Two phidget connectors for 3.3 V sensors.
* Two phidget connectors for 5 V sensors.
* Two phidget connectors, one for 3.3 V and one for 5 V sensors.

.Pin assignement
image::./images/3/image005.png[scaledwidth="80", align="center"]

In the snippet below the ADC channels ADC0 (5V1), ADC3 (5V2), ADC1 (3V1) and ADC7 (3V2) are mapped by default to be used as input for external analogue sensors. 

[source, c]
----
/* MemReg6 == P6.0/A0 == 5V 1 */
ADC12MCTL0 = (INCH_0 + SREF_0);
/* MemReg7 == P6.3/A3 == 5V 2 */
ADC12MCTL1 = (INCH_3 + SREF_0);
/* MemReg8 == P6.1/A1 == 3V 1 */
ADC12MCTL2 = (INCH_1 + SREF_0);
/* MemReg9 == P6.7/A7 == 3V_2 */
ADC12MCTL3 = (INCH_7 + SREF_0);
----

To read from a sensor connected to the ADC7 channel of the Z1 mote, in my code I would need to make the following steps:

[source, c]
----
#include "dev/z1-phidgets.h"                                <1>
SENSORS_ACTIVATE(phidgets);                                 <2>
printf("Phidget 5V 1:%d\n", phidgets.value(PHIDGET3V_2));   <3>
----
<1> Include the driver header
<2> Enable the ADC sensors, as default all 4 ADC channels are enabled
<3> Request a reading

The Z1 is powered at 3.3 V, but when connected over the USB (standard voltage 5 V) it allows to connect 5 V sensors to the phidget ports, namely 5V1 (ADC3) and 5V2 (ADC0) as there is a voltage divider in the input to adapt the reading from 5 V to 3.3 V.

Details about the Z1 implementation of the analogue sensors driver are available at `platform/z1/dev/z1-phidgets.c`.There is also a driver for the MSP430 internal voltage sensor at `platform/z1/dev/battery-sensor.c`, with an example at `examples/zolertia/z1/test-battery.c`.

to see the ADC implementation with an example, let’s connect the Phidget 1142 precision Light Sensor.

.Light sensor
image::./images/3/image006.png[align="center"]

The example called `test-phidgets.c` in `examples/zolertia/z1` will read values from an analog sensor and print them to the terminal.

Connect the light sensor to the 3V2 Phidget connector and compile the example:

[source, bash]
----
make clean && make test-phidgets.upload && make z1-reset && make login
----

[TIP]
====
You can pipeline commands to be executed one after another, in this case the `make z1-reset` restarts the mote after flashed, then `make login` prints to console the output of any `printf` command in our code.  You may need to use the argument `MOTES=/dev/ttyUSB[0...9]` to specify a mote over a particular USB port.
====

This is the result:

[source, bash]
----
Starting 'Test Button & Phidgets'
Please press the User Button
Phidget 5V 1:123
Phidget 5V 2:301
Phidget 3V 1:1710
Phidget 3V 2:2202
----
The light sensor is connected to the 3V2 connector, so the raw value is 2202. Try to illuminate the sensor with a flashlight (from your mobile phone, for example) and then cover it with your hand so that no light can reach it.

From the Phidget website we have the following information about the sensor:

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter         | Value
|Sensor type       | Light
|Light level min   | 1 lux
|Supply Voltage Min| 2.4 V
|Supply Voltage Max| 5.5 V
|Max current consumption| 5mA
|Light level max (3.3 V) | 660 lux
|Light level max (5 V)   | 1000 lux
|======================

As you can see, the light sensor can be connected to either the 5 V or the 3.3 V _Phidget_ connector. The max measurable value depends on where you connect it.

The formula to translate SensorValue into luminosity is:
`Luminosity(lux)=SensorValue`

The *RE-Mote platform* also allows to connect 5 V sensors to the ADC3 port, using the same voltage divider as the Z1 mote.  As seen in the next snippet, the ADC3 port is mapped to the PA2 pin.

[source, c]
----
/* 
 * This driver supports analogue sensors connected to ADC1, ADC2 and AND3 inputs
 * This is controlled by the type argument of the value() function. Possible
 * choices are:
 * - REMOTE_SENSORS_ADC1 (channel 5)
 * - REMOTE_SENSORS_ADC2 (channel 4)
 * - REMOTE_SENSORS_ADC3 (channel 2)
 */
----

.Connecting sensor
image::./images/3/image009.png[align="center"]


Then to read data from an attached sensor (as we did in the previous example):

[source, c]
----
#include "dev/zoul-sensors.h"                                             <1>
adc_sensors.configure(SENSORS_HW_INIT, REMOTE_SENSORS_ADC_ALL);             <2>
printf("Phidget ADC2 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC2));  <3>
printf("Phidget ADC3 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC3));
----
<1> Include the ADC driver header
<2> Enable and configure the ADC channels (can selectively choose which to enable)
<3> Request a reading

Check the RE-Mote example at `example/zolertia/zoul/zoul-demo.c` for more details.

TIP: Exercise: make the sensor take readings as fast as possible. Print to the screen the ADC raw values and the millivolts (as this sensor is linear, the voltage corresponds to the luxes). What are the max and min values you can get? What is the average light value of the room? Create an application that turns the red LED on when it is dark and the green LED on when the room is bright. In between, all the LEDs should be off. Add a timer and measure the light every 10 seconds.

===== Digital Sensors

****
Digital sensors are normally interfaced over a digital communication protocol such as I2C, SPI, 1-Wire, Serial or depending on the manufacturer, a proprietary protocol normally on a ticking clock.

Digital sensors allow a more extended set of commands (turn on, turn off, configure interrupts). With a digital light sensor for example, you could set a threshold value and let the sensor send an interrupt when reached, without the need for continuous polling.

Remember to check the specific sensor information and data sheet for more information.
****

The *Z1 mote* has *two built in digital sensors*: temperature and 3-axis accelerometer.  Let us start with the latter, there is an example called `test-adxl345.c` available for testing.

The ADXL345 is an I2C ultra-low power sensor able to read up to 16g, well suited for mobile device applications.  It
measures the static acceleration of gravity in tilt-sensing applications, as well as dynamic acceleration resulting from motion or shock. Its high resolution (3.9mg/LSB) enables measurement of inclination changes smaller than 1.0°.

[source, bash]
----
[37] DoubleTap detected! (0xE3) -- DoubleTap Tap
x: -1 y: 12 z: 223
[38] Tap detected! (0xC3) -- Tap
x: -2 y: 8 z: 220
x: 2 y: 4 z: 221
x: 3 y: 5 z: 221
x: 4 y: 5 z: 222
----

The accelerometer can read data in the x, y and z axis and has three types of interrupts: a single tap, a double tap and a free-fall (be careful to not damage the mote!).

The code has two threads, one for the interruptions and the other for the LEDs. When Contiki starts, it triggers both processes.

The `led_process` thread triggers a timer that waits before turning off the LEDs. This is mostly done to filter the rapid signal coming from the accelerometer. The other process is the acceleration. It assigns the callback for the `led_off` event.
Interrupts can happen at any given time, are non periodic and totally asynchronous.

Interrupts can be triggered by external sources (sensors, GPIOs, _Watchdog Timer_, etc) and should be cleared as soon as possible. When an interrupts happens, the interrupt handler (which is a process that checks the interrupt registers to find out which is the interrupt source) manages it and forwards it to the subscribed callback.

In this example, the accelerometer is initialized and then the interrupts are mapped to a specific callback functions. Interrupt source 1 is mapped to the _free fall_ callback handler and the tap interrupts are mapped to the interrupt source 2.

[source, c]
----
/*
 * Start and setup the accelerometer with default
 * values, _i.e_ no interrupts enabled.
 */
accm_init();
/* Register the callback functions */
ACCM_REGISTER_INT1_CB(accm_ff_cb);
ACCM_REGISTER_INT2_CB(accm_tap_cb);
----

We then need to enable the interrupts like this:
[source, c]
----
accm_set_irq(ADXL345_INT_FREEFALL,
             ADXL345_INT_TAP +
             ADXL345_INT_DOUBLETAP);
----

In the _while_ loop we read the values from each axis every second.  If there are no interrupts, this will be the only thing shown in the terminal.

TIP: Exercise: put the mote in different positions and check the values of the accelerometer. Try to understand which is x, y and z. Measure the maximum acceleration by shaking the mote. Turn on and off the LED according to the acceleration on one axis.

For the next example we will use the *ZIG-SHT25*, an I2C digital temperature and humidity sensor based on the SHT25 sensor from Sensirion.

.Temperature and humidity sensor
image::./images/3/image007.png[align="center"]

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter              | Value
|Sensor type            | Temperature and Humidity
|Supply Voltage [V]     | 2.1 - 3.6
|Energy Consumption     | 3.2 uW (at 8 bit, 1 measurement / s)
|Data range             | 0-100 % RH (humidity), -40-125ºC (temperature)
|Max resolution         | 14 bits (temperature), 12 bits (humidity)
|Max current consumption| 300 uA
|======================

The ZIG-SHT25 sensor example is available in both `examples/zolertia/zoul/test-sht25.c` and `examples/zolertia/z1/test-sht25.c`, an output example is given below:

[source, bash]
----
Starting 'SHT25 test'
Temperature 23.71 ºC
Humidity 42.95 % RH
Temperature 23.71 ºC
Humidity 42.95 % RH
Temperature 23.71 ºC
Humidity 42.95 % RH
Temperature 23.71 ºC
Humidity 42.98  %RH
----

As usual you can check the driver implementation at the `platform/z1/dev` and `platform/zoul/dev` directories.  Check out these locations for other sensors and examples to guide you to implement your own.

TIP: Exercise: convert the temperature to Fahrenheit. Try to get the temperature and humidity as high as possible (without damaging the mote!). Try to print only “possible” values (if you disconnect the sensor, you should not print anything, or print an error message!).

=== Emulate Contiki with Cooja

Cooja is the Contiki network emulator. Cooja allows large and small networks of Contiki motes to be emulated at the hardware level, which is slower but allows precise inspection of the system behavior, or at a less detailed level, which is faster and allows simulation of larger networks.

Cooja is a highly useful tool for Contiki development as it allows developers to test their code and systems long before running it on the target hardware. Developers regularly set up new simulations both to debug their software and to verify the behavior of their systems.

Most of the examples below can be emulated in Cooja as well (except the sensor ones).

In the terminal window go to the Cooja directory:

[source, bash]
----
cd contiki/tools/cooja
----

Start Cooja with the command:

[source, bash]
----
ant run
----

When Cooja is compiled, it will show a blue empty window. Now that Cooja is up and running, we can try it out with an example simulation.

Go to `File`, `Open Simulation`, `Browse` then navigate to the `examples/hello-world` and select the `hello-world-example.csc`.  This will load the previously saved hello world example.

If you want to edit an example (for istance, to use a different type of platform), instead of choosing the `Browse` option, select `Open and Reconfigure`, this will walk you through the steps to configure the example.

=== Create a new simulation

Click the `File` menu and click `New simulation`. Cooja now opens up the `Create new simulation` dialog. In this dialog, we may choose to give our simulation a new name, but for this example, we'll just stick with `My simulation`. Leave the other options at default values. Click the `Create` button.

Cooja brings up the new simulation. You can choose what you want to visualize by using the `Tools` menu. The `Network` window shows all the motes in the simulated network, it should be empty now since we have no motes in our simulation. The `Timeline` window shows all communication events in the simulation over time - very handy for understanding what goes on in the network. The `Mote output` window shows all serial port printouts from all the motes. The `Notes` window is where we can put notes for our simulation. And the `Simulation control` window is where we start, pause, and reload our simulation.

=== Add motes to the simulation

Before we can simulate our network, we must add one or more motes. We do this via the `Motes` menu, where we click on `Add motes`. Since this is the first mote we add, we must first create a mote type to add. Click `Create new mote type` and select one of the available mote types. For this example, we click `Z1 mote` to create an emulated Z1 mote type. Cooja opens the `Create Mote Type` dialog, in which we can choose a name for our mote type as well as the Contiki application that our mote type will run. 

For this example, we stick with the suggested name, and click on the `Browse` button on the right hand side to choose our Contiki application.

