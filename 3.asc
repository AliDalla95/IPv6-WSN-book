== Introduction to Contiki

Contiki is an open source operating system for the Internet of Things, it connects tiny low-cost, low-power microcontrollers to the Internet.

image::./images/1/image10.png[scaledwidth="20", scaleheight="20"]

Contiki provides powerful low-power Internet communication, it supports fully standard IPv6 and IPv4, along with the recent low-power wireless standards: 6lowpan, RPL, CoAP. With Contiki's ContikiMAC and sleepy routers, even wireless routers can be battery-operated.

With Contiki, development is easy and fast: Contiki applications are written in standard C, with the Cooja simulator Contiki networks can be emulated before burned into hardware, and Instant Contiki provides an entire development environment in a single download.

More information available at:

http://contiki-os.org/

=== Install Contiki

There are several ways to install Contiki, from scratch by installing from sources or using
virtual environments, depending on the flavour and time willing to spend.

To work with Contiki three steps are required:

* Get the Contiki source code.
* A target platform (virtual platform or a real hardware one).
* A toolchain to compile the source code for such target platform.

The remainder of the book assumes Contiki will run in an Unix environment,
as the virtualized environments run on Ubuntu.  Instructions to run these environments on Windows and MAC will
be provided next.

==== Install from sources

Contiki source code is actively supported and contributed by contributors from Universities,
Research centers and developers from all over the world.  The source code is hosted
in GitHub:

https://github.com/contiki-os/contiki

To grab the source code open a terminal and execute the following:

[source, bash]
----
sudo apt-get -y install git
git clone --recursive https://github.com/contiki-os/contiki.git
----

.What is git?
****

*Git* is a free and open source distributed version control system, designed for speed and efficiency.   The main difference with other change control tools, is the possibility to work locally as your local copy is a repository, and you can commit to it and get all benefits of source control.  Making branches and merging between branches is really easy using git.

There are some great tutorials online to learn more about git:

http://try.github.io

http://rogerdudler.github.io/git-guide/

*GitHub* is a GIT repository  web-based hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git as well as adding its own features. GitHub provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, bug tracking and feature requests for every project.

image::./images/1/image00.png[scaledwidth="20", scaleheight="20"]

The advantage of using GIT and hosting the code at github is that of allowing people to fork the code, develop on its own, and then contribute back and share your progress.
****

To install the toolchain and required dependencies, run in a terminal the following:

[source,bash]
----
sudo echo "deb http://ppa.launchpad.net/terry.guo/gcc-arm-embedded/ubuntu trusty main" > /etc/apt/sources.list.d/gcc-arm-embedded.list
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key FE324A81C208C89497EFC6246D1D8367A3421AFB
sudo apt-get update
sudo apt-get -y install build-essential automake gettext
sudo apt-get -y install gcc-arm-none-eabi curl graphviz unzip wget
sudo apt-get -y install gcc gcc-msp430
sudo apt-get -y install openjdk-7-jdk openjdk-7-jre ant
----

This will install support for the ARM Cortex-M3 and MSP430 platforms, as well as
support for Cooja, the Contiki's emulator to be discussed in the next sections.

==== Instant Contiki Virtual Machine

Instant Contiki is an entire Contiki development environment in a single download. It is an Ubuntu Linux virtual machine and has Contiki OS and all the development tools, compilers, and simulators required already pre-installed.

Grab Instant Contiki from Contiki website:

http://www.contiki-os.org/start.html

And download the 32-bit version:

`Instant_Contiki_Ubuntu_12.04_32-bit.vmdk`

On Windows and Linux host you can use VMWare player to run the Virtual Machine:

https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0

On OSX you can download VMWare Fusion: http://www.vmware.com/products/fusion

Using VMWare just open the `InstantContiki2.7.vmx` file, if prompted about the VM source just choose `I copied it` then wait for the virtual Ubuntu Linux boot up.

Log into Instant Contiki. The password and user name is `user`. Don’t upgrade right now.

Remember to update the Contiki repository and get the latest upgrades:

[source,bash]
----
cd /home/user/contiki
git fetch origin
git pull origin master
----

==== Vagrant recipe

==== Docker container

=== Test Contiki installation

Let us first check the toolchain installation.  The MSP430 toolchain can tested with:

[source, bash]
----
msp430-gcc --version
msp430-gcc (GCC) 4.7.0 20120322 (mspgcc dev 20120716)
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----

And the ARM Cortex-M3 toolchain:

[source, bash]
----
arm-gcc-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]  
Copyright (C) 2014 Free Software Foundation, Inc.  
This is free software; see the source for copying conditions.  There is NO  
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----

We are ready to go.

=== Contiki structure

image::./images/1/image11.png[scaledwidth="80%"]

* examples: Contiki's ready to build examples, at `examples/zolertia` you will find specific Zolertia related examples.
* app: Contiki applications.
* cpu: specific MCU files.  In `cpu/msp430/` there are the drivers of the MCU used by the Z1 mote.  The `cpu/cc2538` contains the drivers of the CC2538 ARM Cortex-M3 system on chip.
* platform: specific device files and drivers.  In `platform/z1` there are the drivers and configuration files of the Z1 mote.  The `platform/remote` has the specific RE-Mote's files.
* core: Contiki's filesystem and core components.
* tools: a variety of tools for debugging, simulating and developing.  in `tools/z1` there are specific tools such as the BSL script for programming the devices.  Also two simulation tools provided by Contiki: COOJA and MSPSim are also included.
* doc: self-generated Doxygen documentation.
* regression-tests: set of nightly regression tests that test important aspects of Contiki on a daily basis

=== Emulate Contiki with Cooja

Cooja is the Contiki network emulator. Cooja allows large and small networks of Contiki motes to be emulated at the hardware level, which is slower but allows precise inspection of the system behavior, or at a less detailed level, which is faster and allows simulation of larger networks.

Cooja is a highly useful tool for Contiki development as it allows developers to test their code and systems long before running it on the target hardware. Developers regularly set up new simulations both to debug their software and to verify the behavior of their systems.

To start Cooja,  in the terminal window go to the Cooja directory:

[source, bash]
----
cd contiki/tools/cooja
----

Start Cooja with the command:

[source, bash]
----
ant run
----

When Cooja is compiled, it will start with a blue empty window. Now that Cooja is up and running, we can try it out with an example simulation.

=== Create a new simulation

Click the `File` menu and click `New simulation`. Cooja now opens up the `Create new simulation` dialog. In this dialog, we may choose to give our simulation a new name, but for this example, we'll just stick with `My simulation`. Leave the other options set as default. Click the `Create` button.

Cooja brings up the new simulation. You can choose what you want to visualize by using the `Tools` menu. The `Network` window shows all the motes in the simulated network, it should be empty now since we have no motes in our simulation. The `Timeline` window shows all communication events in the simulation over time - very handy for understanding what goes on in the network. The `Mote output` window shows all serial port printouts from all the motes. The `Notes` window is where we can put notes for our simulation. And the `Simulation control` window is where we start, pause, and reload our simulation.

=== Add motes to the simulation

Before we can simulate our network, we must add one or more motes. We do this via the `Motes` menu, where we click on `Add motes`. Since this is the first mote we add, we must first create a mote type to add. Click `Create new mote type` and select one of the available mote types. For this example, we click `Z1 mote`. to create an emulated Z1 mote type. Cooja opens the `Create Mote Type` dialog, in which we can choose a name for our mote type as well as the Contiki application that our mote type will run. For this example, we stick with the suggested name, and instead click on the `Browse` button on the right hand side to choose our Contiki application.


=== Run Contiki on real hardware

For the remainder of the book we will use the hardware development platforms shown in the next sections, examples other than platform-specifics at `examples/zolertia/z1` and `examples/zolertia/remote` should work for both platforms, with minor tweaks.

More information about both platforms and updates guides can be found at:

http://www.zolertia.

==== Zolertia Z1 mote

image::./images/1/image03.png[]

The Z1 mote features a second generation MSP430F2617 low power 16-bit RISC CPU @16 MHz MCU, 8 kB RAM and a 92 kB Flash memory.  Also includes the well known CC2420 transceiver, IEEE 802.15.4 compliant, which operates at 2.4 GHz with an effective data rate of 250 kbps.

The Zolertia Z1 mote can run TinyOS, Contiki OS, OpenWSN and RIOT, and has been used actively over 5 years now in Universities, Research and development centers and commercial products in more than 43 countries and has been featured in more than 50 scientific publications.

The Z1 mote is fully emulated in both MSPSIM and Cooja.

==== Zolertia RE-Mote

The **RE-Mote** is a hardware development platform. It follows the specifications developed jointly with universities and industrial partners in the frame of the European research project **RERUM**(**RERUM: REliable, Resilient and secUre IoT for sMart city applications**).

Zolertia’s RE-Mote aims to fill the so far persisting gap in existing IoT platforms that lacked the combination of industrial-grade design and ultra-low power operation capability, being at the same time easy to use and highly integrable to existing devices and deployment scenarios.

The RE-Mote is based in the CC2538 ARM Cortex-M3 system on chip (SoC), with an on-board 2.4GHz IEEE 802.15.4 RF, running up to 32Mhz with 512KB of programable flash and 32KB of RAM, bundled with a CC1200 868/915Mhz RF transceiver to allow dual band operation.  The RE-Mote in a nutshell packs:

*   ISM 2.4-GHz IEEE 802.15.4 & Zigbee compliant.
*   ISM 863-950-MHz ISM/SRD Band.
*   AES-128/256, SHA2 Hardware Encryption Engine.
*   ECC-128/256, RSA Hardware Acceleration Engine for Secure Key Exchange.
*   Power consumption down to 300nA using our shutdown mode.
*   Programming over BSL without requiring to press any button to enter bootloader mode.
*   Built-in battery charger (500mA), Energy Harvesting and Solar Panels to be connected to standards LiPo batteries.
*   Power input with wide range 2-16VDC.
*   Small form-factor (as the Z1 mote, half the size of an Arduino) 57x35 mm.
*  MicroSD over SPI.
*  On board RTC (programable real time clock) and external watchdog (WDT).
*  RF switch to programatically route either the 2.4GHz/Sub-1GHz RF interface to a RP-SMA connector, to connect an external antenna.

=== Start with Contiki!

Let's compile our first Contiki example! Open a terminal and write:

[source, bash]
----
cd examples/hello-world
make TARGET=remote savetarget
----

This will tell Contiki from now on to compile the hello world example for the RE-Mote platform.  Alternatively to use the Z1 mote instead just run::

[source, bash]
----
make TARGET=z1 savetarget
----

You need to do this only once per application.  Not let's compile the application:

[source, bash]
----
make hello-world
----

To start compiling the code (ignore the warnings), if everything works OK you should see something like:

[source, bash]
----
CC        symbols.c
AR        contiki-z1.a
CC        hello-world.c
CC        ../../platform/z1/./contiki-z1-main.c
LD        hello-world.z1
rm obj_z1/contiki-z1-main.o hello-world.co
----
The `hello-world.z1` file should have been created and we are ready to flash the application to the device.

At any given point you can override the saved target and redefine at compilation time by running instead:

[source, bash]
----
make TARGET=remote hello-world
----

This will overlook the saved `Makefile.target` file and use the target `remote` instead.

==== Hello world explained

Let’s see the main components of the Hello World example.  View the code with:

[source, bash]
----
gedit hello-world.c
----
When starting Contiki, you declare processes with a name. In each code you can have several processes.
You declare the process like this:

[source, c]
----
PROCESS(hello_world_process, "Hello world process"); // <1>
AUTOSTART_PROCESSES(&hello_world_process); // <2>
----
<1> `hello_world_process` is the name of the process and
`"Hello world process"` is the readable name of the process when you print it to the terminal.
<2> The `AUTOSTART_PROCESSES(&hello_world_process)` tells Contiki to start that process when it finishes booting.

[source, c]
----
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data) <1>
{
  PROCESS_BEGIN(); <2>
  printf("Hello, world\n"); <3>
  PROCESS_END(); <4>
}
----
<1> You declare the content of the process in the process thread. You have the name of the process and callback functions (event handler and data handler).
<2> Inside the thread you begin the process,
<3> do what you want and
<4> finally end the process.

==== Adding LED to the example

The next step is adding a LED (light emitting diode) to interact with our application.

You have to add the `dev/leds.h` which is the library to manage the LEDs.  To check the available functions go to `/home/user/contiki/core/dev/leds.h`.

Available LEDs commands:

[source, c]
----
unsigned char leds_get(void);
void leds_set(unsigned char leds);
void leds_on(unsigned char leds);
void leds_off(unsigned char leds);
void leds_toggle(unsigned char leds);
----

General available LEDs:

[source, c]
----
LEDS_GREEN
LEDS_RED
LEDS_BLUE
LEDS_ALL
----

The RE-Mote uses a RGB LED, basically 3-channel LEDs in a single device, allowing to have the above plus any new color from combining these, for example:

[source, c]
----
LEDS_LIGHT_BLUE
LEDS_YELLOW
LEDS_PURPLE
LEDS_WHITE
----

Now try to turn ON only the red LED and see what happens

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  PROCESS_END();
}
----

Now let’s compile and upload the new project with:

[source, bash]
----
make clean && make hello-world.upload
----

The `make clean` command is used to erase previously compiled objects, this is *very important* because if you make changes to the source code, you must rebuild the files, otherwise your change might not be pulled in.

Now the red LED should be ON!

TIP: Exercise: try to switch on the other LEDs.

==== Printing messages to the console

You can use printf to visualize on the console what is happening in your application.  It is really useful to debug your code, as you can print for istance values of variables, when certain block of code is being executed, etc.

Let’s try to print the status of the LED, using the `unsigned char leds_get(void);` function that is available in the documented functions (see above).

Get the LED status and print its status on the screen.

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
char hello[] = "hello from the mote!";
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  printf("%s\n", hello);
  printf("The LED %u is %u\n", LEDS_RED, leds_get());
  PROCESS_END();
}
----

If one LED is on, you will get the LED number (LEDs are numbered 1, 2 and 4).

TIP: Exercise: what happens when you turn on more than one LED? What number do you get?

==== Adding button events

We now want to detect if the *user button* has been pressed.

The button in Contiki is considered as a sensor. We are going to use the `core/dev/button-sensor.h` library.

TIP: The RE-Mote platform has extra button functionalities, such as detect long-press sequences, enabling to further expand the events that can be triggered using the button.  Check `platform/remote/dev/button-sensor.c` for more details, and `examples/zolertia/remote/remote-demo.c` for an example.

Add the `dev/button-sensor.h` header to our example and add a button event:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  SENSORS_ACTIVATE(button_sensor);
  while(1) {
    PROCESS_WAIT_EVENT_UNTIL((ev==sensors_event) &&
                            (data == &button_sensor)); <1>
    printf("I pushed the button! \n");
  }
  PROCESS_END();
}
----

This process has an infinite loop, given by the `wait()`, to wait for the button the be pressed.  The two conditions have to be met (event from a sensor and that event is the button being pressed), as soon as you press the button, you get the string printed.

TIP: Exercise: switch on the LED when the button is pressed. Switch off the LED when the button is pressed again.

==== Timers

Using timers will allow us to trigger events at a given time, speeding up the transition from one state to another and making a given process or task automated, for example blinking an LED every 5 seconds, without the user having to press the button each time.

Contiki OS provides 4 kind of timers:

* Simple timer: A simple ticker, the application should check _manually_ if the timer has expired.  More information at `core/sys/timer.h`.
* Callback timer: When a timer expires it can callback a given function. More information at `core/sys/ctimer.h`.
* Event timer: Same as above, but instead of calling a function, when the timer expires it posts an event signaling its expiration. More information at `core/sys/etimer.h`.
* Real time timer: The real-time module handles the scheduling and execution of real-time tasks, there's only 1 timer available at the moment.  More information at `core/sys/rtimer.h`

For our implementation we are going to choose the event timer, because we want to change the application behavior when the timer expires every given period.

We create a timer structure and set the timer to expire after a given number of seconds. When the timer expires we execute the code and restart the timer.

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include <stdio.h>
#define  SECONDS 2
/*-------------------------------------------------*/
PROCESS(hello_world_process, "hello world example");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  static struct etimer et;
  while(1) {
    etimer_set(&et, CLOCK_SECOND*SECONDS); <1>
    PROCESS_WAIT_EVENT(); <2>
    if(etimer_expired(&et)) {
      printf("Hello world!\n");
      etimer_reset(&et);
    }
  }
  PROCESS_END();
}
----
<1> `CLOCK_SECOND` is a value related to the number of the microcontroller's ticks per second. As Contiki runs on different platforms with different hardware, the value of `CLOCK_SECOND` also differs.
<2> `PROCESS_WAIT_EVENT()` waits for _any_ event to happen.

TIP: Exercise: can you print the value of `CLOCK_SECOND` to count how many ticks you have in one second? Try to blink the LED for a certain number of seconds. A new application that starts only when the button is pressed and when the button is pressed again it stops.


==== Sensors

Sensors can be of two types: analogue and digitals.

Analog sensors typically require  being connected to an ADC (analog to digital converters) to translate the analog (continuous) reading to an equivalent digital value in millivolts. The quality and resolution of the measure depends on both the ADC (resolution is up to 12 bits in the Z1 and RE-Mote) and on the sampling frequency.

As a rule of thumb, the sampling frequency must be twice that of the phenomenon you are measuring. As an example, if you want to sample human speech (8 kHz) you need to sample at twice that frequency (16 kHz minimum).

Digital sensors are normally interfaced over a digital communication protocol such as I2C, SPI, 1-Wire, Serial or depending on the manufacturer, a proprietary protocol normally on a ticking clock.

The Z1 mote has *two built in digital sensors*: temperature and 3-axis accelerometer, as well as a built-in voltage sensor provided as an ADC input channel.  

The RE-Mote platform has two internal analogue core temperature and voltage, provided as ADC input channels.

===== Analog Sensors

There is an example in the Contiki example folder called `test-battery.c`. The example includes the battery level driver (`battery-sensor.h`). It activates the sensor and prints as fast as possible (with no delay) the battery level.

The example at `examples/zolertia/remote/remote-demo.c` also shows how to use both core temperature and voltage sensors.

When working with the ADC you need to convert the ADC integers in milliVolts. This is done with the following formula:

  mv = (battery * 2.500 * 2) / 4096;

We multiply by the voltage reference and divide the raw value by 4096, as the precision of the ADC is 12 bits (1<<12).

The Z1 is powered at 3.3V but it can be powered at 5V through the USB.  There is an internal voltage divider that converts from 5V to 3.3V when using an analogue sensor in a specific _Phidget_ port, which are basically a connector with a given pin-out based on the commercially available _Phidget_ sensors.

image::./images/1/image04.png[]

More information about the Z1 mote pin-out can be gleaned directly from its datasheet at:

http://zolertia.com/sites/default/files/Zolertia-Z1-Datasheet.pdf

====== External analog sensor:

We can connect an external analog sensor to any of the available phidget ports.  As an example, let’s connect the Phidget 1142 *precision light sensor*.

image::./images/1/image05.png[]

It is important to know the voltage required by each sensor.  If the sensor can be powered at 3V, it should be connected to the Phidgets connector in the top row.  If the sensor is powered at 5V it can be safely connected to the Phidgets bottom row.  You can use the 5V sensor only if the mote is powered by USB.

The Precision Light Sensor product information is available at:

http://www.phidgets.com/products.php?product_id=1142_0

There is an example called `test-phidgets.c`. This will read values from an analog sensor and print them to the terminal.

Connect the light sensor to the 3V Phidget connector.
As this is an official example, there is no need to add it to the Makefile (it is already there!).  Let’s compile the example code:

[source, bash]
----
make clean && make test-phidgets.upload && make z1-reset && make login
----
This is the result:

[source, bash]
----
Starting 'Test Button & Phidgets'
Please press the User Button
Phidget 5V 1:123
Phidget 5V 2:301
Phidget 3V 1:1710
Phidget 3V 2:2202
----
The light sensor is connected to the *Phidget 3V2 connector*, so the raw value is 2202. Try to illuminate the sensor with a flashlight (from your mobile phone, for example) and then cover it with your hand so that no light can reach it.

From the Phidget website we have the following information about the sensor:

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter         | Value
|Sensor type       | Light
|Light level min   | 1 lux
|Supply Voltage Min| 2.4V
|Supply Voltage Max| 5.5V
|Max current consumption| 5mA
|Light level max (3.3V) | 660 lux
|Light level max (5V)   | 1000 lux
|======================

As you can see, the light sensor can be connected to either the 5V or 3.3V _Phidget_ connector. The max measurable value changes depending where you connect it.

The formula to translate SensorValue into luminosity is:
`Luminosity(lux)=SensorValue`

TIP: Exercise: make the sensor take sensor readings as fast as possible. Print on the screen the ADC raw values and the millivolts (as this sensor is linear, the voltage corresponds to the luxes). What are the max and min values you can get? What is the average light value of the room? Create an application that turns the red LED on when it is dark. When it is light, turn the green LED on. In between, switch off all the LEDs. Add a timer and measure the light every 10 seconds.

===== Internal digital sensor

As said earlier, the Z1 mote has a built-in ADXL345 3 axis accelerometer, and there is an example called `test-adxl345.c` available for testing.

The ADXL345 is an I2C ultra-low power sensor able to read up to 16g, well suited for mobile device applications.  It
measures the static acceleration of gravity in tilt-sensing applications, as well as dynamic acceleration resulting from motion or shock. Its high resolution (3.9mg/LSB) enables measurement of inclination changes less than 1.0°.


[source, bash]
----
[37] DoubleTap detected! (0xE3) -- DoubleTap Tap
x: -1 y: 12 z: 223
[38] Tap detected! (0xC3) -- Tap
x: -2 y: 8 z: 220
x: 2 y: 4 z: 221
x: 3 y: 5 z: 221
x: 4 y: 5 z: 222
----

The accelerometer can give data in x, y and z axis and has three types of interrupts: a single tap, a double tap and a free-fall (pay attention not to damage the mote!).

The code has two threads, one for the interruptions and the other for the LEDs. When Contiki starts, it triggers both processes.

The `led_process` thread triggers a timer that waits before turning off the LEDs. This is mostly done to filter the rapid signal coming from the accelerometer. The other process is the acceleration. It assigns the callback for the `led_off` event.
Interrupts can happen at any given time, are non periodic and totally asynchronous.

Interrupts can be triggered by external sources (sensors, GPIOs, _Watchdog Timer_, etc) and should be cleared as soon as possible. When an interrupts happens, the interrupt handler (which is a process that checks the interrupt registers to find out which is the interrupt source) manages it and forwards it to the subscribed callback.

In this example, the accelerometer is initialized and then the interrupts are mapped to a specific callback functions. Interrupt source 1 is mapped to the _free fall_ callback handler and the tap interrupts are mapped to the interrupt source 2.

[source, c]
----
/*
 * Start and setup the accelerometer with default
 * values, _i.e_ no interrupts enabled.
 */
accm_init();
/* Register the callback functions */
ACCM_REGISTER_INT1_CB(accm_ff_cb);
ACCM_REGISTER_INT2_CB(accm_tap_cb);
----

We then need to enable the interrupts like this:
[source, c]
----
accm_set_irq(ADXL345_INT_FREEFALL,
             ADXL345_INT_TAP +
             ADXL345_INT_DOUBLETAP);
----

In the _while_ loop we read the values from each axis every second.  If there are no interrupts, this will be the only thing shown in the terminal.

TIP: Exercise: put the mote in different positions and check the values of the accelerometer. Try to understand what is x, y and z. Measure the maximum acceleration by shaking the mote. Turn on and off the LED according to the acceleration on one axis.

=== External digital sensor

image::./images/1/image06.png[]

The *ZIG-SHT25* is an I2C digital temperature and humidity sensor based on the SHT25 sensor from Sensirion.

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter              | Value
|Sensor type            | Temperature and Humidity
|Supply Voltage [V]     | 2.1 - 3.6
|Energy Consumption     | 3.2 uW (at 8 bit, 1 measurement / s)
|Data range             | 0-100 %RH (humidity), -40-125ºC (temperature)
|Max resolution         | 14 bits (temperature), 12 bits (humidity)
|Max current consumption| 300 uA
|======================

More information available at:

http://webshop.zolertia.com/product_info.php/cPath/29_30/products_id/79

The advantage of using digital sensors is that you don’t have to do calibration of your own, as sensors normally come factory-calibrated.  Digital sensors often have a low power current consumption compared to their analog peers.

Digital sensors allow a more extended set of commands (turn on, turn off, configure interrupts).  With a digital light sensor for example, you could set a threshold value and let the sensor send an interrupt when reached, without the need for continuous polling.

The ZIG-SHT25 sensor example is available as `test-sht25.c`, an output example is given below:

[source, bash]
----
Starting 'SHT25 test'
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.98 %RH
----

TIP: Exercise: convert the temperature to Fahrenheit. Try to get the temperature and humidity as high as possible (without damaging the mote!). Try to print only “possible” values (if you disconnect the sensor, you should not print anything, or print an error message!).
