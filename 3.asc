== Introduction to Contiki

Contiki is an open source operating system for the Internet of Things, it connects tiny low-cost, low-power microcontrollers to the Internet.

Contiki provides powerful low-power Internet communication, it supports fully standard IPv6 and IPv4, along with the recent low-power wireless standards: 6lowpan, RPL, CoAP. With Contiki's ContikiMAC and sleepy routers, even wireless routers can be battery-operated.

With Contiki, development is easy and fast: Contiki applications are written in standard C, with the Cooja simulator Contiki networks can be emulated before burned into hardware, and Instant Contiki provides an entire development environment in a single download.

More information available at:

http://contiki-os.org/

=== Install Contiki

There are several ways to install Contiki, from scratch by installing from sources or using
virtual environments, depending on the flavour and time willing to spend.

To work with Contiki three steps are required:

* Get the Contiki source code.
* A target platform (virtual platform or a real hardware one).
* A toolchain to compile the source code for such target platform.

The remainder of the book assumes Contiki will run in an Unix environment,
as the virtualized environments run on Ubuntu.  Instructions to run these environments on Windows and MAC will
be provided next.

==== Install from sources

Contiki source code is actively supported and contributed by contributors from Universities, Research centers and developers from all over the world.  

The source code is hosted in GitHub:

https://github.com/contiki-os/contiki

To grab the source code open a terminal and execute the following:

[source, bash]
----
sudo apt-get -y install git
git clone --recursive https://github.com/contiki-os/contiki.git
----

.What is git?
****

*Git* is a free and open source distributed version control system, designed for speed and efficiency.   The main difference with other change control tools, is the possibility to work locally as your local copy is a repository, and you can commit to it and get all benefits of source control.

image::./images/3/image001.png[scaledwidth="30"]

Making branches and merging between branches is really easy using git.

There are some great tutorials online to learn more about git:

http://try.github.io

http://rogerdudler.github.io/git-guide/

*GitHub* is a GIT repository  web-based hosting service, which offers all of the distributed revision control and source code management (SCM) functionality of Git as well as adding its own features. GitHub provides a web-based graphical interface and desktop as well as mobile integration. It also provides access control and several collaboration features such as wikis, task management, bug tracking and feature requests for every project.

image::./images/3/image002.png[scaledwidth="50"]

The advantage of using GIT and hosting the code at github is that of allowing people to fork the code, develop on its own, and then contribute back and share your progress.
****

To install the toolchain and required dependencies, run in a terminal the following:

[source, bash]
----
sudo echo "deb http://ppa.launchpad.net/terry.guo/gcc-arm-embedded/ubuntu trusty main" > /etc/apt/sources.list.d/gcc-arm-embedded.list
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key FE324A81C208C89497EFC6246D1D8367A3421AFB
sudo apt-get update
sudo apt-get -y install build-essential automake gettext
sudo apt-get -y install gcc-arm-none-eabi curl graphviz unzip wget
sudo apt-get -y install gcc gcc-msp430
sudo apt-get -y install openjdk-7-jdk openjdk-7-jre ant
----

This will install support for the ARM Cortex-M3 and MSP430 platforms, as well as
support for Cooja, the Contiki's emulator to be discussed in the next sections.

==== Instant Contiki Virtual Machine

Instant Contiki is an entire Contiki development environment in a single download. It is an Ubuntu Linux virtual machine and has Contiki OS and all the development tools, compilers, and simulators required already pre-installed.

Grab Instant Contiki from Contiki website:

http://www.contiki-os.org/start.html

And download the 32-bit version:

`Instant_Contiki_Ubuntu_12.04_32-bit.vmdk`

On Windows and Linux host you can use VMWare player to run the Virtual Machine:

https://my.vmware.com/web/vmware/free#desktop_end_user_computing/vmware_player/6_0

On OSX you can download VMWare Fusion:

http://www.vmware.com/products/fusion

Using VMWare just open the `InstantContiki2.7.vmx` file, if prompted about the VM source just choose `I copied it` then wait for the virtual Ubuntu Linux boot up.

Log into Instant Contiki. The password and user name is `user`. Don’t upgrade right now.

Remember to update the Contiki repository and get the latest upgrades:

[source,bash]
----
cd /home/user/contiki
git fetch origin
git pull origin master
----

==== Vagrant recipe

**** TODO: ADD REPO

==== Docker container

**** TODO: ADD REPO

=== Test Contiki installation

Let us first check the toolchain installation.  The MSP430 toolchain can tested with:

[source, bash]
----
msp430-gcc --version
msp430-gcc (GCC) 4.7.0 20120322 (mspgcc dev 20120716)
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----

And the ARM Cortex-M3 toolchain:

[source, bash]
----
arm-gcc-none-eabi-gcc --version
arm-none-eabi-gcc (GNU Tools for ARM Embedded Processors) 4.9.3 20150529 (release) [ARM/embedded-4_9-branch revision 224288]  
Copyright (C) 2014 Free Software Foundation, Inc.  
This is free software; see the source for copying conditions.  There is NO  
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
----

We are ready to go.

=== Contiki structure

Contiki has the following file structure:

image::./images/3/image003.png[scaledwidth="80%"]

* examples: Contiki's ready to build examples, at `examples/zolertia` you will find specific Zolertia related examples.
* app: Contiki applications.
* cpu: specific MCU files.  In `cpu/msp430/` there are the drivers of the MCU used by the Z1 mote.  The `cpu/cc2538` contains the drivers of the CC2538 ARM Cortex-M3 System on Chip (SoC).
* platform: specific device files and drivers.  In `platform/z1` there are the drivers and configuration files of the Z1 mote.  The `platform/remote` has the specific RE-Mote's files.
* core: Contiki's filesystem and core components.
* tools: a variety of tools for debugging, simulating and developing.  in `tools/z1` there are specific tools such as the BSL script for programming the devices.  Also two simulation tools provided by Contiki: COOJA and MSPSim are also included.
* doc: self-generated Doxygen documentation.
* regression-tests: set of nightly regression tests that test important aspects of Contiki on a daily basis


=== Run Contiki on real hardware

For the remainder of the book we will use Zolertia Z1 and RE-Mote hardware development platforms, shown in the next sections.  Other platforms can be used as well, but are out of the scope of this book.

As Contiki drivers and libraries are (normally) platform independent, most examples can be run in both Z1 and RE-Mote platforms indistinctively, taking into consideration specific platform settings.

There are platform-specific examples for the Z1 platform at `examples/zolertia/z1`, and `examples/zolertia/remote` for the RE-Mote.

More information about both platforms and updates guides can be found at:

http://www.zolertia.

==== Zolertia Z1 mote

image::./images/3/image004.png[scaledwidth="50"]

The *Z1 mote* features a second generation MSP430F2617 low power 16-bit RISC CPU @16 MHz MCU, 8 kB RAM and a 92 kB Flash memory.  Also includes the well known CC2420 transceiver, IEEE 802.15.4 compliant, which operates at 2.4 GHz with an effective data rate of 250 kbps.

The Zolertia Z1 mote can run TinyOS, Contiki OS, OpenWSN and RIOT, and has been used actively over 5 years now in Universities, Research and development centers and commercial products in more than 43 countries and has been featured in more than 50 scientific publications.

The Z1 mote is fully emulated in both MSPSIM and Cooja.

==== Zolertia RE-Mote

The **RE-Mote** is a hardware development platform. It follows the specifications developed jointly with universities and industrial partners in the frame of the European research project **RERUM**(**RERUM: REliable, Resilient and secUre IoT for sMart city applications**).

**** TODO: INCLUDE HERE PHOTO

Zolertia’s RE-Mote aims to fill the so far persisting gap in existing IoT platforms that lacked the combination of industrial-grade design and ultra-low power operation capability, being at the same time easy to use and highly integrable to existing devices and deployment scenarios.

The RE-Mote is based in the CC2538 ARM Cortex-M3 system on chip (SoC), with an on-board 2.4GHz IEEE 802.15.4 RF, running up to 32Mhz with 512KB of programable flash and 32KB of RAM, bundled with a CC1200 868/915Mhz RF transceiver to allow dual band operation.  The RE-Mote in a nutshell packs:

*   ISM 2.4-GHz IEEE 802.15.4 & Zigbee compliant.
*   ISM 863-950-MHz ISM/SRD Band.
*   AES-128/256, SHA2 Hardware Encryption Engine.
*   ECC-128/256, RSA Hardware Acceleration Engine for Secure Key Exchange.
*   Power consumption down to 300nA using our shutdown mode.
*   Programming over BSL without requiring to press any button to enter bootloader mode.
*   Built-in battery charger (500mA), Energy Harvesting and Solar Panels to be connected to standards LiPo batteries.
*   Power input with wide range 2-16VDC.
*   Small form-factor (as the Z1 mote, half the size of an Arduino) 57x35 mm.
*  MicroSD over SPI.
*  On board RTC (programable real time clock) and external watchdog (WDT).
*  RF switch to programatically route either the 2.4GHz/Sub-1GHz RF interface to a RP-SMA connector, to connect an external antenna.

=== Start with Contiki!

Let's compile our first Contiki example! Open a terminal and write:

[source, bash]
----
cd examples/hello-world
make TARGET=remote savetarget
----

This will tell Contiki from now on to compile the hello world example for the RE-Mote platform.  Alternatively to use the Z1 mote instead just run:

[source, bash]
----
make TARGET=z1 savetarget
----

You need to do this only once per application.  Not let's compile the application:

[source, bash]
----
make hello-world
----

To start compiling the code (ignore the warnings), if everything works OK you should see something like:

[source, bash]
----
CC        symbols.c
AR        contiki-z1.a
CC        hello-world.c
CC        ../../platform/z1/./contiki-z1-main.c
LD        hello-world.z1
rm obj_z1/contiki-z1-main.o hello-world.co
----
The `hello-world.z1` file should have been created and we are ready to flash the application to the device.

At any given point you can override the saved target and redefine at compilation time by running instead:

[source, bash]
----
make TARGET=remote hello-world
  AR        contiki-remote.a  
  CC        ../../cpu/cc2538/cc2538.lds  
  CC        ../../cpu/cc2538/./startup-gcc.c  
  CC        hello-world.c  
  LD        hello-world.elf  
arm-none-eabi-objcopy -O ihex hello-world.elf hello-world.hex  
arm-none-eabi-objcopy -O binary --gap-fill 0xff hello-world.elf hello-world.bin  
cp hello-world.elf hello-world.remote  
rm http://hello-world.co/[hello-world.co] obj_remote/startup-gcc.o
----

This will overlook the saved `Makefile.target` file and use the target `remote` instead.

In the following sections and chapters the compiled examples can be compiled for both Z1 and RE-Mote platform, unless specified otherwise.

==== Hello world explained

Let’s see the main components of the Hello World example.  Browse the code with:

[source, bash]
----
gedit hello-world.c
----

Or your preferred text editor.

When starting Contiki, you declare processes with a name. In each code you can have several processes.  You declare the process like this:

[source, c]
----
PROCESS(hello_world_process, "Hello world process"); // <1>
AUTOSTART_PROCESSES(&hello_world_process); // <2>
----
<1> `hello_world_process` is the name of the process and
`"Hello world process"` is the readable name of the process when you print it to the terminal.
<2> The `AUTOSTART_PROCESSES(&hello_world_process)` tells Contiki to start that process when it finishes booting.

[source, c]
----
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data) <1>
{
  PROCESS_BEGIN(); <2>
  printf("Hello, world\n"); <3>
  PROCESS_END(); <4>
}
----
<1> You declare the content of the process in the process thread. You have the name of the process and callback functions (event handler and data handler).
<2> Inside the thread you begin the process,
<3> do what you want and
<4> finally end the process.

==== Makefile explained

Applications require a Makefile to compile, let us take a look at the `hello-world` Makefile:

[source, bash]
----
CONTIKI_PROJECT = hello-world        <1>
all: $(CONTIKI_PROJECT)              <2>
CONTIKI = ../..                      <3> 
include $(CONTIKI)/Makefile.include  <4>
----
<1> Tells the build system which application to compile
<2> If using `make all` it will compile the defined applications
<3> Specify our indentation level respect to Contiki root folder
<4> The system-wide Contiki Makefile, also points out to the platform's Makefile

We can define specific compilation flags in the Makefile, although the 
recommended way would be to add a `project-conf.h` header, and define there
any compilation flag or value.  This is done by adding this to the Makefile:

[source, bash]
----
DEFINES+=PROJECT_CONF_H=\"project-conf.h\"
----

And then creating a `project-conf.h` header file in the example location.

==== Adding LED to the example

The next step is adding a LED (light emitting diode) to interact with our application.

You have to add the `dev/leds.h` which is the library to manage the LEDs.  To check the available functions go to `/home/user/contiki/core/dev/leds.h`.

Available LEDs commands:

[source, c]
----
unsigned char leds_get(void);
void leds_set(unsigned char leds);
void leds_on(unsigned char leds);
void leds_off(unsigned char leds);
void leds_toggle(unsigned char leds);
----

Normally all platforms comply to the following available LEDs:

[source, c]
----
LEDS_GREEN
LEDS_RED
LEDS_BLUE
LEDS_ALL
----

In the Z1 mote these LEDs are defined in `platform/z1/platform-conf.h`, as well as other hardware definitions.

The RE-Mote uses a RGB LED, basically 3-channel LEDs in a single device, allowing to have the above plus any new color from combining these.  In the `platforms/remote/dev/board.h` header the following are defined:

[source, c]
----
LEDS_LIGHT_BLUE
LEDS_YELLOW
LEDS_PURPLE
LEDS_WHITE
----

Now try to turn on only the red LED and see what happens

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  PROCESS_END();
}
----

Now let’s compile and upload the new project with:

[source, bash]
----
make clean && make hello-world.upload
----

The `make clean` command is used to erase previously compiled objects.

Now the red LED should be on!

[CAUTION]
====
If you make changes to the source code, you must rebuild the files, otherwise your change might not be pulled in.  It is always recommended to do a `make clean` command before compiling.
====

TIP: Exercise: try to switch on the other LEDs.

==== Printing messages to the console

You can use printf to visualize on the console what is happening in your application.  It is really useful to debug your code, as you can print values of variables, when certain block of code is being executed, etc.

Let’s try to print the status of the LED, using the `unsigned char leds_get(void);` function that is available in the documented functions (see above).

Get the LED status and print its status on the screen.

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include <stdio.h>
char hello[] = "hello from the mote!";
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  leds_on(LEDS_RED);
  printf("%s\n", hello);
  printf("The LED %u is %u\n", LEDS_RED, leds_get());
  PROCESS_END();
}
----

If one LED is on, you will get the LED number, which is defined by each platform in its `platform-conf.h` or `board.h` header.

TIP: Exercise: what happens when you turn on more than one LED? What number do you get? are these the same numbers for the Z1 and the RE-Mote?

==== Adding button events

We now want to detect if the *user button* has been pressed.

The button in Contiki is considered as a sensor. We are going to use the `core/dev/button-sensor.h` library.

TIP: The RE-Mote platform has extra button functionalities, such as detect long-press sequences, enabling to further expand the events that can be triggered using the button.  Check `platform/remote/dev/button-sensor.c` for more details, and `examples/zolertia/remote/remote-demo.c` for an example.

Add the `dev/button-sensor.h` header to our example and add a button event:

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include <stdio.h>
/*-------------------------------------------------*/
PROCESS(hello_world_process, "Hello world process");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  SENSORS_ACTIVATE(button_sensor);
  while(1) {
    PROCESS_WAIT_EVENT_UNTIL((ev==sensors_event) &&
                            (data == &button_sensor));
    printf("I pushed the button! \n");
  }
  PROCESS_END();
}
----

This process has an infinite loop, given by the `wait()`, to wait for the button the be pressed.  The two conditions have to be met (event from a sensor and that event is the button being pressed), as soon as you press the button, you get the string printed.

TIP: Exercise: switch on the LED when the button is pressed. Switch off the LED when the button is pressed again.

==== Timers

Using timers will allow us to trigger events at a given time, speeding up the transition from one state to another and making a given process or task automated, for example blinking an LED every 5 seconds, without the user having to press the button each time.

Contiki OS provides 4 kind of timers:

* Simple timer: A simple ticker, the application should check _manually_ if the timer has expired.  More information at `core/sys/timer.h`.
* Callback timer: When a timer expires it can callback a given function. More information at `core/sys/ctimer.h`.
* Event timer: Same as above, but instead of calling a function, when the timer expires it posts an event signaling its expiration. More information at `core/sys/etimer.h`.
* Real time timer: The real-time module handles the scheduling and execution of real-time tasks, there's only 1 timer available at the moment.  More information at `core/sys/rtimer.h`

For our implementation we are going to choose the event timer, because we want to change the application behavior when the timer expires every given period.

We create a timer structure and set the timer to expire after a given number of seconds. When the timer expires we execute the code and restart the timer.

[source, c]
----
#include "contiki.h"
#include "dev/leds.h"
#include "dev/button-sensor.h"
#include <stdio.h>
#define  SECONDS 2
/*-------------------------------------------------*/
PROCESS(hello_world_process, "hello world example");
AUTOSTART_PROCESSES(&hello_world_process);
/*-------------------------------------------------*/
PROCESS_THREAD(hello_world_process, ev, data)
{
  PROCESS_BEGIN();
  static struct etimer et;
  while(1) {
    etimer_set(&et, CLOCK_SECOND*SECONDS); <1>
    PROCESS_WAIT_EVENT(); <2>
    if(etimer_expired(&et)) {
      printf("Hello world!\n");
      etimer_reset(&et);
    }
  }
  PROCESS_END();
}
----
<1> `CLOCK_SECOND` is a value related to the number of the microcontroller's ticks per second. As Contiki runs on different platforms with different hardware, the value of `CLOCK_SECOND` also differs.
<2> `PROCESS_WAIT_EVENT()` waits for _any_ event to happen.

TIP: Exercise: can you print the value of `CLOCK_SECOND` to count how many ticks you have in one second? Try to blink the LED for a certain number of seconds. A new application that starts only when the button is pressed and when the button is pressed again it stops.


==== Sensors

A sensor is a transduced whose purpose is to sense or detect a characteristic of its environments, providing a corresponding output, generally as an electrical or optical signal, related to the quantity of the measured variable.

Sensors in Contiki are implemented as follow:

[source, c]
----
SENSORS_SENSOR (sensor, SENSOR_NAME, value, configure, status);
----

This means a method to `configure` the sensor, poll the sensor `status` and request a `value` have to be implemented.  The `sensor` structure contains pointer to these functions.  The arguments for each function are shown below.

[source, c]
----
struct sensors_sensor {
   char *       type;
   int          (* value)     (int type);
   int          (* configure) (int type, int value);
   int          (* status)    (int type);
};
----

The following functions and macros then can be used to work with the sensor:

[source, c]
----
SENSORS_ACTIVATE(sensor)    <1>
SENSORS_DEACTIVATE(sensor)  <2>
sensor.value(type);         <3>
----
<1> Enable the sensor, typically configures and turn the sensor on
<2> Disables the sensor, depending on the sensor it is recommended to save power
<3> Request a value to the sensor.  As one sensor chip might have different types of readings (temperature, humidity, etc.), this is used to specify which measure to take.

[IMPORTANT]
====
Despise this is the default way to implement sensors in Contiki, depending on the sensor and developer, this may vary.  Always check the specific sensor driver implementation for details.  Normally sensors are provided in the same location as the example, in the `dev` folder, or in the `platform/remote/dev` directory for example.
====

The `SENSORS` macro provide external linkage to the sensors defined for the platform and application, allowing to iterate between the available sensors.  The following are the sensors defined as default for the RE-Mote platform:

[source, c]
----
SENSORS (&button_sensor, &vdd3_sensor, &cc2538_temp_sensor, &adc_sensors);
----

[NOTE]
====
The button is considered a sensor in Contiki, as it shares the same sensor implementation
====

This macro extends to:

[source, c]
----
const struct sensors_sensor *sensors[] = {
  &button_sensor,
  &vdd3_sensor,
  &cc2538_temp_sensor,
  &adc_sensors,
  ((void *)0)
};
----

The number of sensors can be found with the `SENSORS_NUM` macro:

[source, c]
----
#define SENSORS_NUM (sizeof(sensors) / sizeof(struct sensors_sensor *))
----

Sensors can be of two types: analogue and digitals.  In the following sections examples will be shown for both types, detailing how to connect and use both the platform's internal sensors and external ones.

===== Analogue Sensors

****
Analogue sensors typically require being connected to an ADC (analogue to digital converters) to translate the analogue (continuous) reading to an equivalent digital value in millivolts. The quality and resolution of the measure depends on both the ADC resolution (up to 12 bits in the Z1 and RE-Mote) and the sampling frequency.

As a rule of thumb, the sampling frequency must be twice that of the phenomenon you are measuring. As an example, if you want to sample human speech (8 kHz) you need to sample at twice that frequency (16 kHz minimum).
****

The Z1 mote has a built-in voltage sensor provided as an ADC input channel, as well as a generic implementation to read external analogue sensors.

[TIP]
====
Analogue sensors can be connected to both Z1 and the RE-Mote over the _phidget_ ports, which are basically 3-pin connectors (Ground, VCC and signal) with 2.54 mm spacing.  This is a legacy name from the Z1 release, as these ports were meant for the commercially available Phidget sensors.  Nowadays there are also sensors from other providers, such as seeedstudio that has the same pin-out but with a different pin spacing (2mm).  This is not a problem, as there are cables to adapt the pin spacing.

image::./images/3/image008.jpg[scaledwidth="20"]

====

When working with the ADC you need to convert the ADC integers in milliVolts. We multiply the measured value by the voltage reference and divide the product by the resolution.  As the precision of the ADC is 12 bits (1<<12), we can use this formula:

  mv = (raw * Vref) / 4096;

The voltage reference limits the range of our measure, meaning if we use a `Vref` of 2.5V, the sensor will saturate when reading values of a voltage higher than 2.5V.  The reference can be choosen while configuring the ADC, in the case of both the Z1 and RE-Mote normally the 3.3V is used.

The Z1 and the RE-Mote allows up to 6 analogue sensors to be connected, but only can be soldered two _phidget_ connector at the same time.

For the RE-Mote is possible to have only one phidget connector for a 3.3V analogue sensor (ADC1), and other one for 5V sensors (ADC3).

[TIP]
====
The RE-Mote is based on an ARM Cortex-M3, this allows to map any given pin to a controller (as opposite as the MSP430, for which a pin has predefined functions other than GPIO), but only pins in the PA port can be used as ADC.
====

For the Z1 mote is possible to have the following combinations (see Figure below):

* Two phidget connectors for 3.3V sensors.
* Two phidget connectors for 5V sensors.
* Two phidget connector, for 3.3V and 5V sensors.

image::./images/3/image005.png[scaledwidth="80"]

As shown in the snippet below, there are mapped as default the ADC channels ADC0 (5V1), ADC3 (5V2), ADC1 (3V1) and ADC7 (3V2) to be used as input for external analogue sensors. 

[source, c]
----
/* MemReg6 == P6.0/A0 == 5V 1 */
ADC12MCTL0 = (INCH_0 + SREF_0);
/* MemReg7 == P6.3/A3 == 5V 2 */
ADC12MCTL1 = (INCH_3 + SREF_0);
/* MemReg8 == P6.1/A1 == 3V 1 */
ADC12MCTL2 = (INCH_1 + SREF_0);
/* MemReg9 == P6.7/A7 == 3V_2 */
ADC12MCTL3 = (INCH_7 + SREF_0);
----

To take a measure from a sensor connected to the ADC7 channel of the Z1 mote, in my code I would need to make the following steps:

[source, c]
----
#include "dev/z1-phidgets.h"                                <1>
SENSORS_ACTIVATE(phidgets);                                 <2>
printf("Phidget 5V 1:%d\n", phidgets.value(PHIDGET3V_2));   <3>
----
<1> Include the driver header
<2> Enable the ADC sensors, as default all 4 ADC channels are enabled
<3> Request a reading

The Z1 is powered at 3.3V, but when connected over the USB (at 5V) allows to connect 5V sensors to the phidget ports, namely 5V1 (ADC3) and 5V2 (ADC0) as there is a voltage divider in the input to adapt the reading from 5V to 3.3V.

Details about the Z1 implementation of the analogue sensors driver is available at `platform/z1/dev/z1-phidgets.c`.  There is also a driver for the MSP430 internal voltage sensor at `platform/z1/dev/battery-sensor.c`, with an example at `examples/z1/test-battery.c`.

Check the ADC implementation with an example, let’s connect the Phidget 1142 precision Light Sensor.

image::./images/3/image006.png[]

There is an example called `test-phidgets.c` in `examples/z1`. This will read values from an analog sensor and print them to the terminal.

Connect the light sensor to the 3V2 Phidget connector and compile the example:

[source, bash]
----
make clean && make test-phidgets.upload && make z1-reset && make login
----

[TIP]
====
You can chain commands to be executed one after another, in this case the `make z1-reset` restarts the mote after flashed, then `make login` prints to console the output of any `printf` command in our code.  You may need to use the argument `MOTES=/dev/ttyUSB[0...9]` to specify a mote over a specific USB port.
====

This is the result:

[source, bash]
----
Starting 'Test Button & Phidgets'
Please press the User Button
Phidget 5V 1:123
Phidget 5V 2:301
Phidget 3V 1:1710
Phidget 3V 2:2202
----
The light sensor is connected to the 3V2 connector, so the raw value is 2202. Try to illuminate the sensor with a flashlight (from your mobile phone, for example) and then cover it with your hand so that no light can reach it.

From the Phidget website we have the following information about the sensor:

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter         | Value
|Sensor type       | Light
|Light level min   | 1 lux
|Supply Voltage Min| 2.4V
|Supply Voltage Max| 5.5V
|Max current consumption| 5mA
|Light level max (3.3V) | 660 lux
|Light level max (5V)   | 1000 lux
|======================

As you can see, the light sensor can be connected to either the 5V or 3.3V _Phidget_ connector. The max measurable value changes depending where you connect it.

The formula to translate SensorValue into luminosity is:
`Luminosity(lux)=SensorValue`

The *RE-Mote platform* also allows to connect 5V sensors to the ADC3 port, using the same voltage divider as the Z1 mote.  As seen in the next snippet, the ADC3 port is mapped to the PA2 pin.

[source, c]
----
/* 
 * This driver supports analogue sensors connected to ADC1, ADC2 and AND3 inputs
 * This is controlled by the type argument of the value() function. Possible
 * choices are:
 * - REMOTE_SENSORS_ADC1 (channel 5)
 * - REMOTE_SENSORS_ADC2 (channel 4)
 * - REMOTE_SENSORS_ADC3 (channel 2)
 */
----

image::./images/3/image009.png[scaledwidth="80"]


Then to read data from an attached sensor (as we did in the previous example):

[source, c]
----
#include "dev/remote-sensors.h"                                             <1>
adc_sensors.configure(SENSORS_HW_INIT, REMOTE_SENSORS_ADC_ALL);             <2>
printf("Phidget ADC2 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC2));  <3>
printf("Phidget ADC3 = %d raw\n", adc_sensors.value(REMOTE_SENSORS_ADC3));
----
<1> Include the ADC driver header
<2> Enable and configure the ADC channels (can selectively choose which to enable)
<3> Request a reading

Check the RE-Mote example at `example/remote/remote-demo.c` for more details.

TIP: Exercise: make the sensor take sensor readings as fast as possible. Print on the screen the ADC raw values and the millivolts (as this sensor is linear, the voltage corresponds to the luxes). What are the max and min values you can get? What is the average light value of the room? Create an application that turns the red LED on when it is dark. When it is light, turn the green LED on. In between, switch off all the LEDs. Add a timer and measure the light every 10 seconds.

===== Digital Sensors

****
Digital sensors are normally interfaced over a digital communication protocol such as I2C, SPI, 1-Wire, Serial or depending on the manufacturer, a proprietary protocol normally on a ticking clock.
****

The Z1 mote has *two built in digital sensors*: temperature and 3-axis accelerometer.

There is an example called `test-adxl345.c` available for testing.

The ADXL345 is an I2C ultra-low power sensor able to read up to 16g, well suited for mobile device applications.  It
measures the static acceleration of gravity in tilt-sensing applications, as well as dynamic acceleration resulting from motion or shock. Its high resolution (3.9mg/LSB) enables measurement of inclination changes less than 1.0°.

[source, bash]
----
[37] DoubleTap detected! (0xE3) -- DoubleTap Tap
x: -1 y: 12 z: 223
[38] Tap detected! (0xC3) -- Tap
x: -2 y: 8 z: 220
x: 2 y: 4 z: 221
x: 3 y: 5 z: 221
x: 4 y: 5 z: 222
----

The accelerometer can give data in x, y and z axis and has three types of interrupts: a single tap, a double tap and a free-fall (pay attention not to damage the mote!).

The code has two threads, one for the interruptions and the other for the LEDs. When Contiki starts, it triggers both processes.

The `led_process` thread triggers a timer that waits before turning off the LEDs. This is mostly done to filter the rapid signal coming from the accelerometer. The other process is the acceleration. It assigns the callback for the `led_off` event.
Interrupts can happen at any given time, are non periodic and totally asynchronous.

Interrupts can be triggered by external sources (sensors, GPIOs, _Watchdog Timer_, etc) and should be cleared as soon as possible. When an interrupts happens, the interrupt handler (which is a process that checks the interrupt registers to find out which is the interrupt source) manages it and forwards it to the subscribed callback.

In this example, the accelerometer is initialized and then the interrupts are mapped to a specific callback functions. Interrupt source 1 is mapped to the _free fall_ callback handler and the tap interrupts are mapped to the interrupt source 2.

[source, c]
----
/*
 * Start and setup the accelerometer with default
 * values, _i.e_ no interrupts enabled.
 */
accm_init();
/* Register the callback functions */
ACCM_REGISTER_INT1_CB(accm_ff_cb);
ACCM_REGISTER_INT2_CB(accm_tap_cb);
----

We then need to enable the interrupts like this:
[source, c]
----
accm_set_irq(ADXL345_INT_FREEFALL,
             ADXL345_INT_TAP +
             ADXL345_INT_DOUBLETAP);
----

In the _while_ loop we read the values from each axis every second.  If there are no interrupts, this will be the only thing shown in the terminal.

TIP: Exercise: put the mote in different positions and check the values of the accelerometer. Try to understand what is x, y and z. Measure the maximum acceleration by shaking the mote. Turn on and off the LED according to the acceleration on one axis.

=== External digital sensor

image::./images/3/image007.png[]

The *ZIG-SHT25* is an I2C digital temperature and humidity sensor based on the SHT25 sensor from Sensirion.

[width="90%",frame="topbot",options="header,footer"]
|======================
|Parameter              | Value
|Sensor type            | Temperature and Humidity
|Supply Voltage [V]     | 2.1 - 3.6
|Energy Consumption     | 3.2 uW (at 8 bit, 1 measurement / s)
|Data range             | 0-100 %RH (humidity), -40-125ºC (temperature)
|Max resolution         | 14 bits (temperature), 12 bits (humidity)
|Max current consumption| 300 uA
|======================

More information available at:

http://webshop.zolertia.com/product_info.php/cPath/29_30/products_id/79

The advantage of using digital sensors is that you don’t have to do calibration of your own, as sensors normally come factory-calibrated.  Digital sensors often have a low power current consumption compared to their analog peers.

Digital sensors allow a more extended set of commands (turn on, turn off, configure interrupts).  With a digital light sensor for example, you could set a threshold value and let the sensor send an interrupt when reached, without the need for continuous polling.

The ZIG-SHT25 sensor example is available as `test-sht25.c`, an output example is given below:

[source, bash]
----
Starting 'SHT25 test'
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.95 %RH
Temperature 23.71 ºC
Humidity 42.98 %RH
----

TIP: Exercise: convert the temperature to Fahrenheit. Try to get the temperature and humidity as high as possible (without damaging the mote!). Try to print only “possible” values (if you disconnect the sensor, you should not print anything, or print an error message!).

=== Emulate Contiki with Cooja

Cooja is the Contiki network emulator. Cooja allows large and small networks of Contiki motes to be emulated at the hardware level, which is slower but allows precise inspection of the system behavior, or at a less detailed level, which is faster and allows simulation of larger networks.

Cooja is a highly useful tool for Contiki development as it allows developers to test their code and systems long before running it on the target hardware. Developers regularly set up new simulations both to debug their software and to verify the behavior of their systems.

Most of the examples done in sections below can be emulated in Cooja as well (except the sensor ones).

To start Cooja,  in the terminal window go to the Cooja directory:

[source, bash]
----
cd contiki/tools/cooja
----

Start Cooja with the command:

[source, bash]
----
ant run
----

When Cooja is compiled, it will start with a blue empty window. Now that Cooja is up and running, we can try it out with an example simulation.

=== Create a new simulation

Click the `File` menu and click `New simulation`. Cooja now opens up the `Create new simulation` dialog. In this dialog, we may choose to give our simulation a new name, but for this example, we'll just stick with `My simulation`. Leave the other options set as default. Click the `Create` button.

Cooja brings up the new simulation. You can choose what you want to visualize by using the `Tools` menu. The `Network` window shows all the motes in the simulated network, it should be empty now since we have no motes in our simulation. The `Timeline` window shows all communication events in the simulation over time - very handy for understanding what goes on in the network. The `Mote output` window shows all serial port printouts from all the motes. The `Notes` window is where we can put notes for our simulation. And the `Simulation control` window is where we start, pause, and reload our simulation.

=== Add motes to the simulation

Before we can simulate our network, we must add one or more motes. We do this via the `Motes` menu, where we click on `Add motes`. Since this is the first mote we add, we must first create a mote type to add. Click `Create new mote type` and select one of the available mote types. For this example, we click `Z1 mote`. to create an emulated Z1 mote type. Cooja opens the `Create Mote Type` dialog, in which we can choose a name for our mote type as well as the Contiki application that our mote type will run. 

For this example, we stick with the suggested name, and instead click on the `Browse` button on the right hand side to choose our Contiki application.

[TIP]
====
Execute the `hello world` example from before in Cooja, see what happens!
====