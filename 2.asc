== Wireless with Contiki:

This section goes as follows:

* Set up the Node ID and MAC address of the Z1 mote.

* Simple application: UDP broadcast.

* Simple application: UDP Server and client.

* Check mote to mote communication.

* Check ETX, LQI, RSSI.

* Change the Radio Frequency Channel and PAN ID.

* Debug: use a Packet sniffer and Wireshark.

* RSSI scanner example application.

=== Set up the Node ID and MAC address of the Z1 mote.

To start working you must first define the Node ID of each node, this will be used to generate the mote's MAC address and the IPv6 addresses (link-local and global).

You can program and store to flash your own.

.Note
****
Since commit `277dc8e1743cdcb253b13861044560464371e1c2` if you don't have stored a Node ID value in flash memory, upon programing the Z1 mote the Product Number (the one displayed earlier over the *make z1-motelist* command) is used instead.

Newer Z1 motes have this number already flashed in the flash memory from factory.

A caveat of this feature is having two motes connected at the same time, as both will be flashed with the same Node ID, as the script doesn't distinguish which mote is connected.

This feature is currently not enabled for MAC OS users.
****

Let's use the ID from the motelist:

[source]
----
Reference  Device       Description
--------------------------------------------------
Z1RC3301   /dev/ttyUSB0 Silicon Labs Zolertia Z1
----

The node ID should be 3301 (decimal) if not previously saved node ID is found in the flash memory.

Let’s see how Contiki uses this to derive a full IPv6 and MAC address.  At `platforms/z1/contiki-z1-main.c`

[source, perl]
----
#ifdef SERIALNUM
  if(!node_id) {
    PRINTF("Node id is not set, using Z1 product ID\n");
    node_id = SERIALNUM;
  }
#endif
node_mac[0] = 0xc1; /* Hardcoded for Z1 */
node_mac[1] = 0x0c; /* Hardcoded for Revision C */
node_mac[2] = 0x00; /* Hardcoded to arbitrary even number so that the 802.15.4 MAC address is compatible with an Ethernet MAC address - byte 0 (byte 2 in the DS ID) */
node_mac[3] = 0x00; /* Hardcoded */
node_mac[4] = 0x00; /* Hardcoded */
node_mac[5] = 0x00; /* Hardcoded */
node_mac[6] = node_id >> 8;
node_mac[7] = node_id & 0xff;
}
----

So the  node’s addresses the mote should have will be :

[source, perl]
----
MAC c1:0c:00:00:00:00:0c:e5
Node id is set to 3301.
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5
----
Where 0xce5 is the hex value corresponding to 3301.  The global address is only set when an IPv6 prefix is assigned (more about this later).

If you wish instead to have your own addressing scheme, you can edit the node_mac values at `Contiki-z1-main.c` file.  If you wish to assign a different node id value than the obtained from the product id, then you would need to store a new one in the flash memory, luckily there is already an application to do so:

Go to `examples/z1` location and replace the `158` for your own required value:

[source]
----
make clean && make burn-nodeid.upload nodeid=158 nodemac=158 && make z1-reset && make login
----
You should see the following:

[source, perl]
----
MAC c1:0c:00:00:00:00:0c:e5 Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 3301.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0ce5
Starting 'Burn node id'
Burning node id 158
Restored node id 158
----

As you can see, now the node ID has been changed to 158, when you restart the mote you should now see that the changes are applied:

[source, perl]
----
MAC c1:0c:00:00:00:00:00:9e Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 158.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
----

=== UDP Broadcast

In this example, we will show how nodes can send data over the air and get to know the basics of Contiki IPv6/RPL implementation.  This example contains a simple Contiki application that randomly broadcasts a UDP packet to its neighbors

We will use a simple version of UDP called `simple-UDP`.

image::./images/2/image14.jpg[]

UDP uses a simple connectionless transmission model with a minimum of protocol mechanism. It has no handshaking dialogues, and thus exposes any unreliability of the underlying network protocol to the user's program.

There is no guarantee of delivery, ordering, or duplicate protection. UDP is suitable for purposes where error checking and correction is either not necessary or it is performed in the application, avoiding the overhead of such processing at the network interface level. Time-sensitive applications often use UDP because dropping packets is preferable to waiting for delayed packets, which may not be an option in a real-time system.

Wireless sensor networks often use UDP because it is lighter and there are less transactions (which can be translated in less energy consumption). A protocols using UDP is COAP (see later).

Go to:

[source]
----
cd examples/ipv6/simple-udp-rpl
----

And open the `broadcast-example.c` and the `Makefile`. Let’s see the contents of the `Makefile`:

[source, perl]
----
UIP_CONF_IPV6=1
CFLAGS+= -DUIP_CONF_IPV6_RPL
----

The above adds the IPv6 stack and RPL routing protocol to our application.

The `broadcast-example.c` contains:

[source]
----
#include "net/ip/uip.h"
----

This is the main IP library.

[source, perl]
----
/* Network interface and stateless autoconfiguration */
#include "net/ipv6/uip-ds6.h"
/* Use simple-udp library, at core/net/ip/ */
/* The simple-udp module provides a significantly simpler API. */
#include "simple-udp.h"
static struct simple_udp_connection broadcast_connection;
----

This structure allows to store the UDP connection information and mapped callback in which to process any received message.  It is initialized below in the following call:

[source]
----
simple_udp_register(&broadcast_connection, UDP_PORT, NULL, UDP_PORT, receiver);
----

This passes to the simple-udp application the ports from/to handle the broadcasts, and the callback function to handle received broadcasts.  We pass the NULL parameter as the destination address to allow packets from any address.

The receiver callback function is shown below:

[source]
----
receiver(struct simple_udp_connection *c,
       const uip_ipaddr_t *sender_addr,
       uint16_t sender_port,
       const uip_ipaddr_t *receiver_addr,
       uint16_t receiver_port,
       const uint8_t *data,
       uint16_t datalen);
----

This application first sets a timer and when the timer expires it sets a randomly generated new timer interval (between 1 and the sending interval) to avoid flooding the network. Then it sets the IP address to the link local all-nodes multicast address as follows:

[source]
----
uip_create_linklocal_allnodes_mcast(&addr);
----

And then use the `broadcast_connection` structure (with the values passed at register) and send our data over UDP.

[source]
----
simple_udp_sendto(&broadcast_connection, "Test", 4, &addr);
----

To extend the available address information, theres a library which already allows to print the IPv6 addresses in a friendlier way, add this to the top of the file:

[source, perl]
----
#include "debug.h"
#define DEBUG DEBUG_PRINT
#include "net/ip/uip-debug.h"
----

So we can now print the multicast address, add this before the `simple_udp_sendto(...)` call:

[source, perl]
----
PRINT6ADDR(&addr);
printf("\n");
----

Now let’s modify our receiver callback and print more information about the incoming message, replace the existing receiver code with the following:

[source, perl]
----
static void
receiver(struct simple_udp_connection *c,
       const uip_ipaddr_t *sender_addr,
       uint16_t sender_port,
       const uip_ipaddr_t *receiver_addr,
       uint16_t receiver_port,
       const uint8_t *data,
       uint16_t datalen)
{
  /* Modified to print extended information */
  printf("\nData received from: ");
  PRINT6ADDR(sender_addr);
  printf("\nAt port %d from port %d with length %d\n",
        receiver_port, sender_port, datalen);
  printf("Data Rx: %s\n", data);
}
----

Before uploading your code, override the default target by writing in the terminal:

[source]
----
make TARGET=z1 savetarget
----

Now clean any previous compiled code, compile, upload your code and then restart the z1 mote, and print the serial output to screen (all in one command!):

[source]
----
make clean && make broadcast-example.upload && make z1-reset && make login
----

TIP: Upload this code to at least 2 motes and send/receive messages from neighbors.  If you have more than 1 Z1 Mote connected in your PC, remember to use the MOTES=/dev/ttyUSBx argument in the upload, reset and login commands!

You will see the following result:

[source, perl]
----
Rime started with address 193.12.0.0.0.0.0.158
MAC c1:0c:00:00:00:00:00:9e Ref ID: 3301
Contiki-2.6-1803-g03f57ae started. Node id is set to 158.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:009e
Starting 'UDP broadcast example process'
Sending broadcast to -> ff02::1

Data received from: fe80::c30c:0:0:309
At port 1234 from port 1234 with length 4
Data Rx: Test
Sending broadcast to -> ff02::1
----

TIP: Exercise:  replace the _Test_ string with your group’s name and try to identify others. Also write down the node ID of other motes. This will be useful for later.

To change the sending interval you can also modify the values at:

[source]
----
#define SEND_INTERVAL  (20 * CLOCK_SECOND)
#define SEND_TIME      (random_rand() % (SEND_INTERVAL))
----

=== Setting up a sniffer
One of the must-have tools when developing wireless applications is a sniffer, which is basically a promiscuous wireless interface able to capture data and decode into a human-readable format.

A packet sniffer is a must-have tool for any wireless network application, a sniffer allows to actually see what are you transmitting over the air, verifying both that the transmissions are taking place, the frames/packets are properly formatted, and that the communication is happening on a given channel.

There are commercial options available, such as the Texas Instruments SmartRF packet Sniffer (http://www.ti.com/tool/packet-sniffer), which can be executed using a CC2531 USB dongle (http://www.ti.com/tool/CC2531EMK) which allows capturing outgoing packets like the one below.

image::./images/2/image00.png[scaledwidth="75%"]

For the remainder of this practice we will use Wireshark as our Packet analyzer, and we will learn about Open Source sniffers available.

==== Short intro to Wireshark

image::./images/2/image08.png[]

This example uses Wireshark to capture and examine a packet trace.  More information and installation instructions are available at:

https://www.wireshark.org/

A packet trace is a record of traffic at some location on the network, as if a snapshot was taken of all the bits that passed across a particular wire.  The packet trace records a timestamp for each packet, along with the bits that make up the packet, from the low-layer headers to the higher-layer contents.

Wireshark runs on most operating systems, including Windows, Mac and Linux. It provides a graphical UI that shows the sequence of packets and the meaning of the bits when interpreted as protocol headers and data. The packets are color-coded to convey their meaning, and Wireshark includes various ways to filter and analyze them to let you investigate different aspects of behavior. It is widely used to troubleshoot networks.

A common usage scenario is when a person wants to troubleshoot network problems or look at the internal workings of a network protocol. An user could, for example, see exactly what happens when he or she opens up a website or set up a wireless sensor network.  It is also possible to filter and search on given packet attributes, which facilitates the debugging process.

When you open Wireshark, there’s a couple of toolbars at the top, an area called Filter, and a few boxes below in the main window. Online directly links you to Wiresharks site, a handy user guide, and information on the security of Wireshark. Under Files, you’ll find Open, which lets you open previously saved captures, and Sample Captures. You can download any of the sample captures through this website, and study the data. This will help you understand what kind of packets Wireshark can capture.

Lastly there is the Capture section. This will let you choose your Interface. You can see each of the interfaces that are available. It’ll also show you which ones are active. Clicking details will show you some pretty generic information about that interface.

Under Start, you can choose one or more interfaces to check out. Capture Options allows you to customize what information you see during a capture. Take a look at your Capture Options – here you can choose a filter, a capture file, and more. Under Capture Help, you can read up on how to capture, and you can check info on Network Media about which interfaces work on which platforms.

Let’s select an interface and click Start. To stop a capture, press the red square in the top toolbar. If you want to start a new capture, hit the green triangle which looks like a shark fin next to it. Now that you have got a finished capture, you can click File, and save, open, or merge the capture. You can print it, you can quit the program, and you can export your packet capture in a variety of ways.

Under edit you can find a certain packet, with the search options you can copy packets, you can mark (highlight) any specific packet or all the packets. Another interesting thing you can do under Edit, is resetting the time value. You’ll notice that the time is in seconds incrementing. You can reset it from the packet you’ve clicked on. You can add a comment to a packet, configure profiles and preferences.

A hands-on session using a Z1 mote as a sniffer will help using Wireshark.

==== SenSniff IEEE 802.15.4 wireless sniffer

We will use for this practice the *SenSniff* application, freely available at: https://github.com/g-oikonomou/sensniff

Paired with a Z1 mote and Wireshark (already installed in instant Contiki), this setup will allow us to understand how the wireless communication is done in Contiki.

To program the Z1 mote as a packet Sniffer go to the following location:

[source]
----
cd examples/z1/sniffer
----

In the `project-conf.h` select the channel to sniff, by changing the `RF_CHANNEL` and `CC2420_CONF_CHANNEL` definitions.  At the moment of writing this tutorial changing channels from the Sensniff application was not implemented but proposed as a feature, check the Sensniff’s `README.md` for changes and current status.

Compile and program:

[source]
----
make sniffer.upload
----

Do not open a login session because the sniffer application uses the serial port to send its findings to the sensniff python script.  Open a new terminal, and clone the sensniff project in your home folder:

[source, perl]
----
cd $HOME
git clone https://github.com/g-oikonomou/sensniff
cd sensniff/host
----

Then launch the sensniff application with the following command:

[source, perl]
----
python sensniff.py --non-interactive -d /dev/ttyUSB0 -b 115200
----

Sensniff will read data from the mote over the serial port, dissect the frames and pipe to `/tmp/sensniff` by default, now we need to connect the other extreme of the pipe to wireshark, else you will get the following warning:

[source]
----
 "Remote end not reading"
----

Which is not worrysome, it only means that the other pipe endpoint is not connected.  You can also save the sniffed frames to open later with wireshark, adding the following argument to the above command `-p name.pcap`, which will save the session output in a `name.pcap` file.  Change the naming and location where to store the file accordingly.

Open another terminal and launch wireshark with the following command, which will add the pipe as a capture interface:

[source]
----
sudo wireshark -i /tmp/sensniff
----

Select the `/tmp/sensniff` interface from the droplist and click `Start` just above.

image::./images/2/image06.png[]

Make sure that the pipe is configured to capture packets in promiscuous mode, if needed you can increase the buffer size, but 1MB is normally enough.

image::./images/2/image07.png[]

Now the captured frames should start to appear on screen.

image::./images/2/image03.png[scaledwidth="75%"]

You can add specific filters to limit the frames being shown on screen, for this example click at the `Expression` button and a list of available attributes per protocol are listed, scroll down until IEEE 802.15.4 and check the available filters.  You can also chain different filter arguments using the `Filter` box, in this case we only wanted to check the frames belonging to the `PAN 0xABCD` and coming from node `c1:0c::0309`, so we used the `wpan.dst_pan` and  `wpan.src64` attributes.

image::./images/2/image13.png[scaledwidth="75%"]

When closing the Sensniff python application, a session information is provided reporting the statistics:

[source, perl]
----
Frame Stats:
         Non-Frame: 6
         Not Piped: 377
    Dumped to PCAP: 8086
             Piped: 7709
          Captured: 8086
----

TIP: Excercise: sniff the traffic! try to filter outgoing and incoming data packets using your own custom rules.

==== Foren6

Another must-to-have tool for analyzing and debugging 6loWPAN/IPv6 networks is Foren6 http://cetic.github.io/foren6/, It uses a passive sniffer devices to reconstruct a visual and textual representation of network information, with a friendly graphical user interface and customizable layout, and also allows to rewind the packet capture history and replay a previous packet trace.

image::./images/2/image01.png[scaledwidth="%"]

To install follow the instructions at http://cetic.github.io/foren6/install.html

To program a Z1 mote as sniffer:

[source, perl]
----
git clone https://github.com/cetic/Contiki
cd Contiki
git checkout sniffer
cd examples/sniffer
make TARGET=z1.upload
----

To connect to Foren6, a basic step-by-step guide for the Z1 mote is available at the link below:

http://cetic.github.io/foren6/example2.html

Open the `Manage Sources` dialog by clicking the Manage Sources button in the Toolbar or from the `File` menu, then click `Start` and visualize your network.

image::./images/2/image11.png[scaledwidth="30%"]

=== Simple application: UDP Server and client

Normal UDP or TCP transactions require a server-client model, in which the communication is made using  a socket, which is an IP address and a port number. What we will do in this example is to forward to the receiver connected to a PC (via USB) temperature sensor data to be published to Ubidots.

TIP: You will need two nodes. The one sending the temperature data is the server, while the one connected to the PC via USB is the client.

This example relies on a service ID, which allows registering, disseminating, and looking up services. A service is identified by an 8-bit integer between 1 and 255. Integers below 128 are reserved for system services. When setting up the example, we need to decide a service ID for the temperature data. The advantage is that the servers (senders of data) don’t need to know the address of the receiver. It is a subscription model where we only need to agree on the service number ID.

We have three groups:

* Group 1 hosts the client that received the data from Groups 2 and 3.

* Group 2 and 3 are the servers that transmit data.  Group 2 sends temperature data and has service ID number 190. Group 3 sends acceleration data and has service ID number 191.

*Server side*:

Open `examples/ipv6/simple-udp-rpl/unicast-sender.c`

First we are going to add

[source, perl]
----
#include "serial-ubidots.h"
#include "dev/i2cmaster.h"
----

*Group 2*:
[source, perl]
----
#include "dev/tmp102.h"
#define SERVICE_ID 190
#define UDP_PORT 1234
----

*Group 3*:
[source, perl]
----
#include "dev/adxl345.h"
#define SERVICE_ID 190
#define UDP_PORT 5678
----

Change the poll rate to something faster:
[source, perl]
----
#define SEND_INTERVAL  (15 * CLOCK_SECOND)
----

We have declared a structure at `apps/serial-ubidots.h` to store the Variable ID and data to be pushed to Ubidots, this will be helpful when sending data wirelessly to the receiver.  This is already declared at `serial-ubidots.h`, do not add this to the example.

[source, perl]
----
struct ubidots_msg_t {
  char var_key[VAR_LEN];
  uint8_t value[2];
};
----

Declare a structure in our code and a pointer to this structure as below:
[source, perl]
----
static struct ubidots_msg_t msg;
static struct ubidots_msg_t *msgPtr = &msg;
----

These structures are used to send Ubidots specific information.

In this application we are going to use global IPv6 addresses besides the link-local ones, the function set_global_address initializes our IPv6 address with the prefix aaaa::, and generates also the link local addressing based on the MAC address.

[source, perl]
----
static void
set_global_address(void)
{
  uip_ipaddr_t ipaddr;
  int i;
  uint8_t state;
  /* Initialize the IPv6 address as below */
  uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);
  /* Set the last 64 bits of an IP address based on the MAC address */
  uip_ds6_set_addr_iid(&ipaddr, &uip_lladdr);
  /* Add to our list addresses */
  uip_ds6_addr_add(&ipaddr, 0, ADDR_AUTOCONF);
  printf("IPv6 addresses: ");
  for(i = 0; i < UIP_DS6_ADDR_NB; i++) {
    state = uip_ds6_if.addr_list[i].state;
    if(uip_ds6_if.addr_list[i].isused &&
      (state == ADDR_TENTATIVE || state == ADDR_PREFERRED)) {
      uip_debug_ipaddr_print(&uip_ds6_if.addr_list[i].ipaddr);
      printf("\n");
    }
  }
}
----

Now inside the `PROCESS_THREAD(unicast_sender_process, ev, data)`, right after the `set_global_address()` call, we initialize our sensors:

*Group 2:*
[source]
----
int16_t temp;
tmp102_init();
----

*Group 3:*
[source]
----
accm_init();
----

And we pass our variable ID obtained at Ubidots to the ubidots message structure as follows:

[source]
----
memcpy(msg.var_key, "545a202b76254223b5ffa65f", VAR_LEN);
printf("VAR %s\n", msg.var_key);
----

This function returns the address of the node offering a specific service. If the service is not known, the function returns _NULL_. If there is more than one node offering the service, this function returns the address of the node that announced its service most recently.

[source]
----
addr = servreg_hack_lookup(SERVICE_ID);
----

If we have the receiver node in our services list, then we take a measure from the sensor, pack it into the byte buffer, and send the information to the receiver node by passing the structure as an array using the pointer to the structure, specifying the size in bytes.

The `UBIDOTS_MSG_LEN` is the sum of the Variable ID string length (24 bytes) plus the sensor reading size (2 bytes).

Replace the existing `if (addr != NULL)` block with the following:

*Group 2:*
[source, perl]
----
if (addr != NULL) {
    temp = tmp102_read_temp_x100();
    msg.value[0] = (uint8_t)((temp & 0xFF00) >> 8);
    msg.value[1] = (uint8_t)(temp & 0x00FF);
    printf("Sending temperature reading -> %d via unicast to ", temp);
    uip_debug_ipaddr_print(addr);
    printf("\n");
    simple_udp_sendto(&unicast_connection, msgPtr, UBIDOTS_MSG_LEN, addr);
} else {
    printf("Service %d not found\n", SERVICE_ID);
}
----

*Group 3:*

Replace inside the `if (addr != NULL)` conditional with the following:
[source, perl]
----
msg.value[0] = accm_read_axis(X_AXIS);
msg.value[1] = accm_read_axis(Y_AXIS);
printf("Sending temperature reading -> %d via unicast to ", temp);
uip_debug_ipaddr_print(addr);
printf("\n");
simple_udp_sendto(&unicast_connection, msgPtr, UBIDOTS_MSG_LEN, addr);
----

And finally add the serial-ubidots app to our `Makefile`:

[source]
----
APPS = servreg-hack serial-ubidots
----

If the address is NULL it can mean that the receiver node is not present yet.

[source, perl]
----
connecting to /dev/ttyUSB0 (115200) [OK]
Rime started with address 193.12.0.0.0.0.3.9
MAC c1:0c:00:00:00:00:03:09 Ref ID: 255
Contiki-2.6-1796-ga50bc08 started. Node id is set to 377.
CSMA ContikiMAC, channel check rate 8 Hz, radio channel 26
Tentative link-local IPv6 address fe80:0000:0000:0000:c30c:0000:0000:0309
Starting 'Unicast sender example process'
IPv6 addresses: aaaa::c30c:0:0:309
fe80::c30c:0:0:309
VAR 545a202b76254223b5ffa65f
Service 190 not found
----

*Client side:*

Open `examples/ipv6/simple-udp-rpl/unicast-receiver.c` and add the Ubidots app:

[source]
----
#include "serial-ubidots.h"
----

Add the services we are interested in, each to be received in a different UDP port:

[source]
----
#define SERVICE_ID 190
#define UDP_PORT_TEMP  1234
#define UDP_PORT_ACCEL 5678
----

You can delete the  `SERVICE_ID`, `SEND_INTERVAL` and `SEND_TIME` definitions.

.A quick RPL intro
****
RPL is on the IETF standards track for routing in low-power and lossy networks. The protocol is tree-oriented in the sense that one or more root nodes in a network may generate a topology that trickles downward to leaf nodes.

In each RPL instance multiple Directed Acyclic Graphs (DAGs) may exist, each having a different DAG root. A node may join multiple RPL instances, but must only belong to one DAG within each instance.
****

The receiver creates the RPL DAG and becomes the network root with the same prefix as the servers:

[source, perl]
----
static void
create_rpl_dag(uip_ipaddr_t *ipaddr)
{
  struct uip_ds6_addr *root_if;

  root_if = uip_ds6_addr_lookup(ipaddr);
  if(root_if != NULL) {
  rpl_dag_t *dag;
  uip_ipaddr_t prefix;

  rpl_set_root(RPL_DEFAULT_INSTANCE, ipaddr);
  dag = rpl_get_any_dag();
  uip_ip6addr(&prefix, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);
  rpl_set_prefix(dag, &prefix, 64);
  PRINTF("created a new RPL dag\n");
  } else {
  PRINTF("failed to create a new RPL DAG\n");
  }
}
----

We should now subscribe to both services (temperature and acceleration), let’s replace the `simple_udp_register` call inside the `PROCESS_THREAD` block, after the `servreg_hack_register(...)`  call with the following:

[source, perl]
----
simple_udp_register(&unicast_connection, UDP_PORT_TEMP,
                    NULL, UDP_PORT_TEMP, receiver);
simple_udp_register(&unicast_connection, UDP_PORT_ACCEL,
                    NULL, UDP_PORT_ACCEL, receiver);
----

And at the receiver callback, replace with the following:

[source, perl]
----
static void
receiver(struct simple_udp_connection *c,
       const uip_ipaddr_t *sender_addr,
       uint16_t sender_port,
       const uip_ipaddr_t *receiver_addr,
       uint16_t receiver_port,
       const uint8_t *data,
       uint16_t datalen)
{
  char var_key[VAR_LEN];
  int16_t value;
  printf("Data received from ");
  uip_debug_ipaddr_print(sender_addr);
  printf(" on port %d from port %d\n",
       receiver_port, sender_port);
  if ((receiver_port == UDP_PORT_TEMP) || (receiver_port == UDP_PORT_ACCEL)){
    /* Copy the data and send to ubidots, restore missing null termination char */
    memcpy(var_key, data, VAR_LEN);
    var_key[VAR_LEN] = "\0";
    value =  data[VAR_LEN] << 8;
    value += data[VAR_LEN + 1];
    printf("Variable -> %s : %d\n", var_key, value);
    send_to_ubidots("fd6c3eb63433221e0a6840633edb21f9ec398d6a", var_key, value);
  }
}
----

Once the sender and the receivers have started, the following messages are shown on the screen of the receiver:

[source, perl]
----
Starting 'Unicast receiver example process'
IPv6 addresses: aaaa::c30c:0:0:2
fe80::c30c:0:0:2
Data received from aaaa::c30c:0:0:309 on port 1234 from port 1234
Variable -> 545a202b76254223b5ffa65f : 2712

fd6c3eb63433221e0a6840633edb21f9ec398d6a    545b43f776254256ebbef0a6   2712
----

==== IEEE 802.15.4 channels and PAN ID

The IEEE 802.15.4 standard is intended to abide to established radio frequency regulations and defines specific physical (PHY) layers according to the country's regulations, 2.4GHz is available almost everywhere, but in the lower band some countries use 868MHz while others use 915MHz as unlicensed frequencies.

The Z1 motes operate on the unlicensed and worldwide available 2.4GHz band, The modulation scheme used is Direct Sequence Spread Spectrum (DSSS) with up to 250 kbps data rate, allowing a wireless range of 50-100 meters.

A total of 16 channels are available in the 2.4GHz band, numbered 11 to 26, each with a bandwidth of 2 MHz and a channel separation of 5 MHz.  As other technologies also share this band, such as WiFi based on IEEE 802.11 and Bluetooth based on IEEE 802.15, we should strive to choose channels that are not currently used by other devices.



As shown above the channels 15, 20, 25 and 26 are not overlapping WiFi assigned channels, so typically most IEEE 802.15.4 based devices tend to operate on this frequencies.  One handy tool to have is a spectrum analyser to scan the wireless medium, which shows the wireless activity on a given band. A spectrum analyzer will show you the received power at a certain frequency, so you will not know if the power comes from another node, a WiFi device or even a microwave oven!  We can use the Z1 mote as a simple spectrum analyser, which sweeps across the list of supported channels and shows the current received power.

To install the spectrum analyser application in the Z1 mote go to the following directory:

[source]
user@instant-Contiki:~/Contiki$ cd examples/z1/rssi_scanner

Compile, upload and execute the Java application to visualize the received power across channels:

[source]
make rssi-scanner.upload && make viewrssi

The result are shown below.




You can change the default 26 radio channel in Contiki by changing or redefining the following defines: `RF_CHANNEL`

But, where are this constants declared? Let’s use a handy command line utility that allows to search for files and content within files, most useful when you need to find a declaration, definition, a file in which an error/warning message is printed, etc.  To find where this definition is used by the Z1 platform use this command:

[source]
user@instant-Contiki:~/Contiki/platform/z1$ grep -lr "RF_CHANNEL" .

Which gives the following result:

[source]
----
./Contiki-conf.h
----

Basically grep as used above uses the following arguments: `-lr` instructs the utility to search recursively through the directories for the required content between the quotes, from our current location (noted by the dot at the end of the command) traversing the directories structure.

The `platform/z1/Contiki-conf.h` shows the following information regarding the `RF_CHANNEL`

[source]
----
#ifdef RF_CHANNEL
#define CC2420_CONF_CHANNEL RF_CHANNEL
#endif

#ifndef CC2420_CONF_CHANNEL
#define CC2420_CONF_CHANNEL           26
#endif /* CC2420_CONF_CHANNEL */
----

So we could either change the channel value directly in this file, but this change would affect other applications that perhaps need to operate on a different channel, so we could just override the `RF_CHANNEL` instead by adding the following to our applications `Makefile`:

[source]
CFLAGS += -DRF_CHANNEL=26

Or adding the following argument at compilation time:

[source]
DEFINES=RF_CHANNEL=26

The `PAN ID` is a unique Personal Area Network identifier that distinguishes our network from others in the same channel, thus allowing to subdivide a given channel into sub-networks, each having its own network traffic.  By default in Contiki and for the Z1 mote the `PAN ID` is defined as`0xABCD`.

TIP: Exercise: Search where the PAN_ID is declared (hint: it has the 0xABCD value) and change to something different, then use the Z1 Sniffer and Wireshark to check if the changes were applied.  Keep in mind that for 2 devices to talk to each other, they must have the same PAN ID.  You can also program the Z1 Sniffer and your test application on a channel other than 26.


==== ETX, LQI, RSSI.

Link Quality Estimation is an integral part of assuring reliabilit in wireless networks. Various link estimation metrics have been proposed to effectively measure the quality of wireless links.



The ETX metric, or expected transmission count, is a measure of the quality of a path between two nodes in a wireless packet data network. ETX is the number of expected transmissions of a packet necessary for it to be received without error at its destination. This number varies from one to infinity. An ETX of one indicates a perfect transmission medium, where an ETX of infinity represents a completely non-functional link. Note that ETX is an expected transmission count for a future event, as opposed to an actual count of a past event. It is hence a real number, generally not an integer.

ETX can be used as the routing metric. Routes with a lower metric are preferred. In a route that includes multiple hops, the metric is the sum of the ETX of the individual hops.

LQI (Link Quality Indicator) is a digital value often provide by Chipset vendors as an indicator of how well a signal is demodulated, in terms of the strength and quality of the received packet, thus indicating a good or bad wireless medium.  The CC2420 radio frequency transceiver used by the Z1 mote typically ranges from 110 (indicates a maximum quality frame) to 50 (typically the lowest quality frames detectable by the transceiver).  The example below shows how the Packet Reception Rate decreases as the LQI decreases.



RSSI (Received Signal Strenght Indicator) is a generic radio receiver technology metric used internally in a wireless networking device to determine the amount of radio energy received in a given channel.  The end-user will likely observe an RSSI value when measuring the signal strength of a wireless network through the use of a wireless network monitoring tool like Wireshark, Kismet or Inssider.

There is no standardized relationship of any particular physical parameter to the RSSI reading, Vendors and chipset makers provide their own accuracy, granularity, and range for the actual power (measured as mW or dBm) and their range of RSSI values (from 0 to RSSI_Max), in the case of the CC2420 radio frequency transceiver on the Z1 mote, the RSSI can range from 0 to -100, values close to 0 are related to good links and values close to -100 are closely related to a bad link, due to multiple factors such as distance, environmental, obstacles, interferences, etc.  The image below shows how the Packet Reception Rate (PRR) dramatically decreases as the CC2420 RSSI values worsen.




To print the current channel, RSSI and LQI of the last received packet (the relevant attributes of the link between the node and the sender), we are going to revisit the `unicast-receiver.c` example; open the file and include the following:

[source]
#include "dev/cc2420/cc2420.h"

Add the following print statement in the receiver block.  The external variables `cc2420_last_rssi` and `cc2420_last_correlation` (LQI) are updated on a new incoming packet, so it should match our received packet.

[source]
printf("CH: &u RSSI: %d LQI %u\n", cc2420_get_channel(), cc2420_last_rssi, cc2420_last_correlation);

We should see something like the following:

[source]
Data received from aaaa::c30c:0:0:309 on port 1234 from port 1234
CH: 26 RSSI: -27 LQI 105
Variable -> 545b43f776254256ebbef0a6 : 2650


TIP: Exercise: Z1 motes come in two models: one with an integrated antenna and another with an external antenna. The integrated antenna is a ceramic antenna from Yageo/Phycomp, connected to the CC2420. The external antenna can be connected via a u.FL connector.
Try to move away from the receiver and check the received signal on your laptop. What is the max distance at which the trasmission is successful? What is the nominal value of RSSI at 50 m with line of sight? Build an application that blinks a green LED when the RSSI is above -55 and a red LED when the RSSI is lower than -55. Does changing the node height and orientation change the RSSI value? If you have one, test the RSSI with an external directional antenna.



== Intro to 6LoWPAN

One of the drivers of the IoT, where anything can be connected, is the use of wireless technologies to get a communication channel to send and receive information.
This wide adoption of wireless technologies allows increasing the number of connected devices but results in limitations in terms of cost, battery life, power consumption, or communication distance for the devices. New technologies and protocols should tackle a new environment, usually called Low power and Lossy networks (LLNs), with the following characteristics:

  . Significantly more devices than those on current local area networks.
  . Severely limited code and ram space in devices.
  . Networks with limited communications distance (range), power and processing resources.
  . All elements should work together to optimize energy consumption and bandwidth usage.

Another feature that is being widely adopted within IoT is the use of IP as the network protocol. The use of IP provides several advantages, because it is an open standard that is widely available, allowing for easy and cheap adoption, good interoperability and easy application layer development. The use of a common standard like an end-to-end IP-based solution avoids the problem of non-interoperable networks interconnected by protocol

For wireless communication technology, the IEEE 802.15.4 standard [IEEE802.15.4] is very promising for the lower (link and physical) layers, although others are also being considered as good options like Low Power WiFi, Bluetooth (R) Low Energy, DECT Ultra Low Energy, ITU-T G.9959 networks, or NFC (Near Field Communication).

One component of the IoT that has received significant support from vendors and standardization organizations is that of WSN (Wireless Sensor Networks).

The IETF has different working groups (WGs) developing standards to be used by WSN:

. *6lowpan*: IPv6 over Low-power Wireless Personal Area Networks [6lowpan], defined the standards needed to have IPv6 communication over the IEEE 802.15.4 wireless communication technology. 6lowpan act as an adaptation layer between the standard IPv6 world and the low power and lossy communications wireless media offered by IEEE 802.15.4. Note that this standard is only defined with IPv6 in mind, no IPv4 support available.
. *roll*: Routing Over Low power and Lossy networks [roll]. LLNs have specific routing requirements that could not be satisfied with existing routing protocols. This WG focuses on routing solutions for a subset of all possible application areas of LLNs (industrial, connected home, building and urban sensor networks), and protocols are designed to satisfy their application-specific routing requirements. Here again the WG focuses only on IPv6 routing architectural framework.
. *6lo*: IPv6 over Networks of Resource-constrained Nodes [6lo]. This WG deals with IPv6 connectivity over constrained node networks. It extends the work of the 6lowpan WG, defining IPv6-over-foo adaptation layer specifications using 6LoWPAN for link layer in constrained node networks.

As seen, 6LoWPAN is the basis of the work carried out in standardization at IETF to communicate constrained resources nodes in LLNs using IPv6. The work on 6LoWPAN is completed and is being further complemented by the roll WG to satisfy routing needs and the 6lo WG to extend the 6lowpan standards to any other link layer technology.
Following are more details about 6LoWPAN, as the first step into the IPv6 based WSN/IoT.
6LoWPAN and related standards are concerned about providing IP connectivity to devices, irrelevantly of the upper layers, except for the UDP transport layer protocol that is specifically considered.

==== Overview of LoWPANs
Low-power and lossy networks (LLNs) is the term commonly used to refer to networks made of highly constrained nodes (limited CPU, memory, power) interconnected by a variety of "lossy" links (low-power radio links).  They are characterized by low speed, low performance, low cost, and unstable connectivity.

A LoWPAN is a particular instance of an LLN, formed by devices complying with the IEEE 802.15.4 standard.

The typical characteristics of devices in a LoWPAN are:

.	*Limited Processing Capability*: Different types and clock speeds processors, starting at 8-bits.
.	*Small Memory Capacity*: From few kilobytes of RAM with a few dozen kilobytes of ROM/flash memory, it’s expected to grow in the future, but always trying to keep at the minimum necessary.
.	*Low Power*: In the order of tens of milliamperes.
.	*Short Range*: The Personal Operating Space (POS) defined by IEEE 802.15.4 implies a range of 10 meters.  For real implementations it can reach over 100 meters in line-of-sight situations.
.	*Low Cost*: This drives some of the other characteristics such as low processing, low memory, etc.

All this constraints on the nodes are expected to change as technology evolves, but compared to other fields it’s expected that the LoWPANs will always try to use very restricted devices to allow for low prices and long life which implies hard restrictions in all other features.

A LoWPAN typically includes devices that work together to connect the physical environment to real-world applications, e.g., wireless sensors, although a LoWPAN is not necessarily comprised of sensor nodes only, since it may also contain actuators.

It's also important to identify the characteristics of LoWPANs, because they will be the constraints guiding all the technical work:

.	Small packet size:  Given that the maximum physical layer frame is 127 bytes, the resulting maximum frame size at the media access control layer is 102 octets.  Link-layer security imposes further overhead, which leaves a maximum of 81 octets for data packets.
.	IEEE 802.15.4 defines several addressing modes: It allows the use of either IEEE 64-bit extended addresses or (after an association event) 16-bit addresses unique within the PAN (Personal Area Network).
.	Low bandwidth: Data rates of 250 kbps, 40 kbps, and 20 kbps for each of the currently defined physical layers (2.4GHz, 915MHz, and 868MHz, respectively).
.	Topologies include star and mesh.
.	Large number of devices expected to be deployed during the lifetime of the technology.
	Location of the devices is typically not predefined, as they tend to be deployed in an ad-hoc fashion. Sometimes the location of these devices may not be easily accessible or they may move to new locations.
.	Devices within LoWPANs tend to be unreliable due to variety of reasons: uncertain radio connectivity, battery drain, device lockups, physical tampering, etc.
.	Sleeping mode: Devices may sleep for long periods of time in order to conserve energy, and are unable to communicate during these sleep periods.

==== About the use of IP on LoWPANs

As said before, it seems that the use of IP, and specifically IPv6, is being widely adopted because it offers several advantages. 6LoWPANs are IPv6-based LoWPAN networks.

In this section we will see these advantages and some problems raised by the use of IP over LoWPANs.

The application of IP technology and, in particular, IPv6 networking is assumed to provide the following benefits to LoWPANs:

..	The pervasive nature of IP networks allows leveraging existing infrastructure.
..	IP-based technologies already exist, are well-known, proven to be working and widely available. This allows for an easier and cheaper adoption, good interoperability and easier application layer development.
..	IP networking technology is specified in open and freely available specifications, which is able to be better understood by a wider audience than proprietary solutions.
..	Tools for IP networks already exist.
..	IP-based devices can be connected readily to other IP-based networks, without the need for intermediate entities like protocol translation gateways or proxies.
..	The use of IPv6, specifically, allows for a huge amount of addresses and provides for easy network parameters autoconfiguration (SLAAC). This is paramount for 6LoWPANs where large number of devices should be supported.

On the counter side using IP communication in LoWPANs raise some issues that should be taken into account:

..	IP Connectivity: One of the characteristics of 6LoWPANs is the limited packet size, which implies that headers for IPv6 and layers above must be compressed whenever possible.
..	Topologies: LoWPANs must support various topologies including mesh and star: Mesh topologies imply multi-hop routing to a desired destination. In this case, intermediate devices act as packet forwarders at the link layer. Star topologies include provisioning a subset of devices with packet forwarding functionality. If, in addition to IEEE 802.15.4, these devices use other kinds of network interfaces such as Ethernet or IEEE 802.11, the goal is to seamlessly integrate the networks built over those different technologies. This, of course, is a primary motivation to use IP to begin with.
..	Limited Packet Size: Applications within LoWPANs are expected to originate small packets. Adding all layers for IP connectivity should still allow transmission in one frame, without incurring excessive fragmentation and reassembly.  Furthermore, protocols must be designed or chosen so that the individual "control/protocol packets" fit within a single 802.15.4 frame.
..	Limited Configuration and Management: Devices within LoWPANs are expected to be deployed in exceedingly large numbers. Additionally, they are expected to have limited display and input capabilities. Furthermore, the location of some of these devices may be hard to reach. Accordingly, protocols used in LoWPANs should have minimal configuration, preferably work "out of the box", be easy to bootstrap, and enable the network to self heal given the inherent unreliable characteristic of these devices.
..	Service Discovery: LoWPANs require simple service discovery network protocols to discover, control and maintain services provided by devices.
..	Security: IEEE 802.15.4 mandates link-layer security based on AES, but it omits any details about topics like bootstrapping, key management, and security at higher layers.  Of course, a complete security solution for LoWPAN devices must consider application needs very carefully.

==== 6LoWPAN

We have seen that there is a lower layer (physical and link layers on TCP/IP stack model) that provide connectivity to devices in what is called a LoWPAN. Also that using IPv6 over this layer would bring several benefits. The main reason for developing the IETF standards mentioned in the introduction is that between the IP (network layer) and the lower layer there are some important issues that need to be solved by means of an adaptation layer, the 6lowpan.

image::./images/2/image15.png[]

The main goals of 6lowpan are:

.	Fragmentation and Reassembly layer: IPv6 specification [RFC2460] establishes that the minimum MTU that a link layer should offer to the IPv6 layer is 1280 bytes. The protocol data units may be as small as 81 bytes in IEEE 802.15.4. To solve this difference a fragmentation and reassembly adaptation layer must be provided at the layer below IP.
.	Header Compression: Given that in the worst case the maximum size available for transmitting IP packets over an IEEE 802.15.4 frame is 81 octets, and that the IPv6 header is 40 octets long, (without optional extension headers), this leaves only 41 octets for upper-layer protocols, like UDP and TCP.  UDP uses 8 octets in the header and TCP uses 20 octets.  This leaves 33 octets for data over UDP and 21 octets for data over TCP.  Additionally, as pointed above, there is also a need for a fragmentation and reassembly layer, which will use even more octets leaving very few octets for data.  Thus, if one were to use the protocols as is, it would lead to excessive fragmentation and reassembly, even when data packets are just 10s of octets long.  This points to the need for header compression.
.	Address Autoconfiguration: specifies methods for creating IPv6 stateless address auto configuration (in contrast to stateful) that is attractive for 6LoWPANs, because it reduces the configuration overhead on the hosts.  There is a need for a method to generate the IPv6 IID (Interface Identifier) from the EUI-64 assigned to the IEEE 802.15.4 device.
.	Mesh Routing Protocol: A routing protocol to support a multi-hop mesh network is necessary. Care should be taken when using existing routing protocols (or designing new ones) so that the routing packets fit within a single IEEE 802.15.4 frame.
The mechanisms defined by 6lowpan IETF WG are based on some requirements for the IEEE 802.15.4 layer:
.	IEEE 802.15.4 defines four types of frames: beacon frames, MAC command frames, acknowledgement frames and data frames. IPv6 packets must be carried on data frames.
.	Data frames may optionally request that they be acknowledged.  It is recommended that IPv6 packets be carried in frames for which acknowledgements are requested so as to aid link-layer recovery.
.	The specification allows for frames in which either the source or destination addresses (or both) are elided. Both source and destination addresses are required to be included in the IEEE 802.15.4 frame header.
.	The source or destination PAN ID fields may also be included. 6LoWPAN standard assumes that a PAN maps to a specific IPv6 link.
.	Both 64-bit extended addresses and 16-bit short addresses are supported, although additional constraints are imposed on the format of the 16-bit short addresses.
.	Multicast is not supported natively in IEEE 802.15.4. Hence, IPv6 level multicast packets must be carried as link-layer broadcast frames in IEEE 802.15.4 networks. This must be done such that the broadcast frames are only heeded by devices within the specific PAN of the link in question.

The 6LoWPAN adaptation format was specified to carry IPv6 datagrams over constrained links, taking into account limited bandwidth, memory, or energy resources that are expected in applications such as wireless sensor networks. For each of these goals and requirements there is a solution provided by the 6lowpan specification:

.	A Mesh Addressing header to support sub-IP forwarding.
.	A Fragmentation header to support the IPv6 minimum MTU requirement.
.	A Broadcast Header to be used when IPv6 multicast packets must be sent over the IEEE 802.15.4 network.
.	Stateless header compression for IPv6 datagrams to reduce the relatively large IPv6 and UDP headers down to (in the best case) several bytes.
These header are used as the LoWPAN encapsulation, and could be used at the same time forming what is called the header stack. Each header in the header stack contains a header type followed by zero or more header fields. When more than one LoWPAN header is used in the same packet, they must appear in the following order: Mesh Addressing Header, Broadcast Header, and Fragmentation Header.

image::./images/2/image16.png[]


==== IPv6 Interface Identifier (IID)

As already said an IEEE 802.15.4 device could have two types of addresses. For each one there is a different way of generating the IPv6 IID.

.	IEEE EUI-64 address: All devices have this one. In this case, the Interface Identifier is formed from the EUI-64, complementing the "Universal/Local" (U/L) bit, which is the next-to-lowest order bit of the first octet of the EUI-64.  Complementing this bit will generally change a 0 value to a 1.

image::./images/2/image17.png[]


.	16-bit short addresses: Possible but not always used. The IPv6 IID is formed using the PAN (or zeroes in case of not knowing the PAN) and the 16 bit short address as in the figure below.

image::./images/2/image18.png[]


==== Header Compression

Two encoding formats are defined for compression of IPv6 packets: LOWPAN_IPHC and LOWPAN_NHC, an encoding format for arbitrary next headers.

To enable effective compression, LOWPAN_IPHC relies on information pertaining to the entire 6LoWPAN. LOWPAN_IPHC assumes the following will be the common case for 6LoWPAN communication:

.	Version is 6.
.	Traffic Class and Flow Label are both zero.
.	Payload Length can be inferred from lower layers from either the 6LoWPAN Fragmentation header or the IEEE 802.15.4 header.
.	Hop Limit will be set to a well-known value by the source.
.	Addresses assigned to 6LoWPAN interfaces will be formed using the link-local prefix or a small set of routable prefixes assigned to the entire 6LoWPAN.
.	Addresses assigned to 6LoWPAN interfaces are formed with an IID derived directly from either the 64-bit extended or the 16-bit short IEEE 802.15.4 addresses.
Depending on how closely the packet matches this common case, different fields may not be compressible thus needing to be carried "in-line" as well. The base format used in LOWPAN_IPHC encoding is shown in the figure below.

image::./images/2/image19.png[]


Where:

-	TF: Traffic Class, Flow Label.
-	NH: Next Header.
-	HLIM: Hop Limit.
-	CID: Context Identifier Extension.
-	SAC: Source Address Compression.
-	SAM: Source Address Mode.
-	M: Multicast Compression.
-	DAC: Destination Address Compression.
-	DAM: Destination Address Mode.

Not going into details, it’s important to understand how 6LoWPAN compression works.
To this end, let’s see two examples:

1.	HLIM (Hop Limit): Is a two bits field that can have four values, three of them make the hop limit field to be compressed from 8 to 2 bits:
a.	00:  Hop Limit field carried in-line. There is no compression and the whole field is carried in-line after the LOWPAN_IPHC.
b.	01:  Hop Limit field compressed and the hop limit is 1.
c.	10:  Hop Limit field compressed and the hop limit is 64.
d.	11:  Hop Limit field compressed and the hop limit is 255.

2.	SAC/DAC used for the source IPv6 address compression. SAC indicates which address compression is used, stateless (SAC=0) or stateful context-based (SAC=1). Depending on SAC, DAC is used in the following way:
a.	If SAC=0, then SAM:

-	00: 128 bits. Full address is carried in-line. No compression.
-	01: 64 bits. First 64-bits of the address are elided,  the link-local prefix. The remaining 64 bits are carried in-line.
-	10: 16 bits. First 112 bits of the address are elided. First 64 bits is the link-local prefix. The following 64 bits are 0000:00ff:fe00:XXXX, where XXXX are the 16 bits carried in-line.
-	11: 0 bits. Address is fully elided.  First 64 bits of the address are the link-local prefix. The remaining 64 bits are computed from the encapsulating header (e.g., 802.15.4 or IPv6 source address).

b.	If SAC=1, then SAM:

-	00: 0 bits. The unspecified address (::).
-	01: 64 bits. The address is derived using context information and the 64 bits carried in-line. Bits covered by context information are always used.  Any IID bits not covered by context information are taken directly from the corresponding bits carried in-line.
-	10: 16 bits. The address is derived using context information and the 16 bits carried in-line. Bits covered by context information are always used.  Any IID bits not covered by context information are taken directly from their corresponding bits in the 16-bit to IID mapping given by 0000:00ff:fe00:XXXX, where XXXX are the 16 bits carried in-line.
-	11: 0 bits. The address is fully elided and it is derived using context information and the encapsulating header (e.g., 802.15.4 or IPv6 source address).  Bits covered by context information are always used.  Any IID bits not covered by context information are computed from the encapsulating header.

The base format is two bytes (16 bits) long. If the CID (Context Identifier Extension) field has a value of 1, it means that an additional 8-bit Context Identifier Extension field immediately follows the Destination Address Mode (DAM) field. This would make the length be 24 bits or three bytes.

This additional octet identifies the pair of contexts to be used when the IPv6 source and/or destination address is compressed. The context identifier is 4 bits for each address, supporting up to 16 contexts. Context 0 is the default context. The two fields on the Context Identifier Extension are:

-	SCI: Source Context Identifier. Identifies the prefix that is used when the IPv6 source address is statefully compressed.
-	DCI: Destination Context Identifier. Identifies the prefix that is used when the IPv6 destination address is statefully compressed.

The Next Header field in the IPv6 header is treated in two different ways, depending on the values indicated in the NH (Next Header) field of the LOWPAN_IPHC enconding shown above.

If NH = 0, then this field is not compressed and all the 8 bits are carried in-line after the LOWPAN_IPHC.

If NH = 1, then the Next Header field is compressed and the next header is encoded using LOWPAN_NHC encoding. This results in the structure shown in the figure below.

image::./images/2/image20.png[]



For IPv6 Extension headers the LOWPAN_NHC has the format shown in the figure, where:

-	EID: IPv6 Extension Header ID:
*	0: IPv6 Hop-by-Hop Options Header.
*	1: IPv6 Routing Header.
*	2: IPv6 Fragment Header.
*	3: IPv6 Destination Options Header.
*	4: IPv6 Mobility Header.
*	5: Reserved.
*	6: Reserved.
*	7: IPv6 Header.

-	NH: Next Header
**	0: Full 8 bits for Next Header are carried in-line.
**	1: Next Header field is elided and is encoded using LOWPAN_NHC.
For the most part, the IPv6 Extension Header is carried unmodified in the bytes immediately following the LOWPAN_NHC octet.

==== NDP optimization

IEEE 802.15.4 and other similar link technologies have limited or no usage of multicast signaling due to energy conservation. In addition, the wireless network may not strictly follow the traditional concept of IP subnets and IP links. IPv6 Neighbor Discovery was not designed for non-transitive wireless links, as its reliance on the traditional IPv6 link concept and its heavy use of multicast make it inefficient and sometimes impractical in a low-power and lossy network.

For this reasons, some simple optimizations have been defined for IPv6 Neighbor Discovery, its addressing mechanisms and duplicate address detection for LoWPANs [RFC6775]:

.	Host-initiated interactions to allow for sleeping hosts.
.	Elimination of multicast-based address resolution for hosts.
.	A host address registration feature using a new option in unicast Neighbor Solicitation (NS) and Neighbor Advertisement (NA) messages.
.	A new Neighbor Discovery option to distribute 6LoWPAN header compression context to hosts.
.	Multihop distribution of prefix and 6LoWPAN header compression context.
.	Multihop Duplicate Address Detection (DAD), which uses two new ICMPv6 message types.

The two multihop items can be substituted by a routing protocol mechanism if that is desired.

Three new ICMPv6 message options are defined:

.	The Address Registration Option (ARO).
.	The Authoritative Border Router Option (ABRO).
.	The 6LoWPAN Context Option (6CO)

Also two new ICMPv6 message types are defined:

.	The Duplicate Address Request (DAR).
.	The Duplicate Address Confirmation (DAC)


